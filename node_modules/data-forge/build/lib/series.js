"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var empty_iterable_1 = require("./iterables/empty-iterable");
var count_iterable_1 = require("./iterables/count-iterable");
var multi_iterable_1 = require("./iterables/multi-iterable");
var select_iterable_1 = require("./iterables/select-iterable");
var select_many_iterable_1 = require("./iterables/select-many-iterable");
var take_iterable_1 = require("./iterables/take-iterable");
var take_while_iterable_1 = require("./iterables/take-while-iterable");
var where_iterable_1 = require("./iterables/where-iterable");
var concat_iterable_1 = require("./iterables/concat-iterable");
var series_window_iterable_1 = require("./iterables/series-window-iterable");
var reverse_iterable_1 = require("./iterables/reverse-iterable");
var zip_iterable_1 = require("./iterables/zip-iterable");
var distinct_iterable_1 = require("./iterables/distinct-iterable");
var series_rolling_window_iterable_1 = require("./iterables/series-rolling-window-iterable");
var series_variable_window_iterable_1 = require("./iterables/series-variable-window-iterable");
var ordered_iterable_1 = require("./iterables/ordered-iterable");
var index_1 = require("./index");
var extract_element_iterable_1 = require("./iterables/extract-element-iterable");
var skip_iterable_1 = require("./iterables/skip-iterable");
var skip_while_iterable_1 = require("./iterables/skip-while-iterable");
// @ts-ignore
var easy_table_1 = __importDefault(require("easy-table"));
var dataframe_1 = require("./dataframe");
// @ts-ignore
var dayjs_1 = __importDefault(require("dayjs"));
// @ts-ignore
var customParseFormat_1 = __importDefault(require("dayjs/plugin/customParseFormat"));
dayjs_1.default.extend(customParseFormat_1.default);
var utils_1 = require("./utils");
var __1 = require("..");
var numeral_1 = __importDefault(require("numeral"));
;
/**
 * Class that represents a series containing a sequence of indexed values.
 */
var Series = /** @class */ (function () {
    /**
     * Create a series.
     *
     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object.
     *
     * It can be an array that specifies the values that the series contains.
     *
     * It can be a {@link ISeriesConfig} that defines the values and configuration of the series.
     *
     * Or it can be a function that lazily produces a {@link ISeriesConfig}.
     *
     * @example
     * <pre>
     *
     * const series = new Series();
     * </pre>
     *
     * @example
     * <pre>
     *
     * const series = new Series([10, 20, 30, 40]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const series = new Series({ index: [1, 2, 3, 4], values: [10, 20, 30, 40]});
     * </pre>
     *
     * @example
     * <pre>
     *
     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [10, 20, 30, 40] });
     * const series = new Series(lazyInit);
     * </pre>
     */
    function Series(config) {
        //
        // Function to lazy evaluate the configuration of the series.
        //
        this.configFn = null;
        //
        // The content of the series.
        // When this is null it means the series is yet to be lazy initialised.
        //
        this.content = null;
        if (config) {
            if (utils_1.isFunction(config)) {
                this.configFn = config;
            }
            else if (utils_1.isArray(config) ||
                utils_1.isFunction(config[Symbol.iterator])) {
                this.content = Series.initFromArray(config);
            }
            else {
                this.content = Series.initFromConfig(config);
            }
        }
        else {
            this.content = Series.initEmpty();
        }
    }
    //
    // Initialise series content from an array of values.
    //
    Series.initFromArray = function (arr) {
        return {
            index: Series.defaultCountIterable,
            values: arr,
            pairs: new multi_iterable_1.MultiIterable([Series.defaultCountIterable, arr]),
            isBaked: true,
        };
    };
    //
    // Initialise an empty series.
    //
    Series.initEmpty = function () {
        return {
            index: Series.defaultEmptyIterable,
            values: Series.defaultEmptyIterable,
            pairs: Series.defaultEmptyIterable,
            isBaked: true,
        };
    };
    //
    // Check that a value is an interable.
    //
    Series.checkIterable = function (input, fieldName) {
        if (utils_1.isArray(input)) {
            // Ok
        }
        else if (utils_1.isFunction(input[Symbol.iterator])) {
            // Assume it's an iterable.
            // Ok
        }
        else {
            // Not ok
            throw new Error("Expected '" + fieldName + "' field of Series config object to be an array of values or an iterable of values.");
        }
    };
    ;
    //
    // Initialise series content from a config object.
    //
    Series.initFromConfig = function (config) {
        var index;
        var values;
        var pairs;
        var isBaked = false;
        if (config.pairs) {
            Series.checkIterable(config.pairs, "pairs");
            pairs = config.pairs;
        }
        if (config.index) {
            Series.checkIterable(config.index, "index");
            index = config.index;
        }
        else if (pairs) {
            index = new extract_element_iterable_1.ExtractElementIterable(pairs, 0);
        }
        else {
            index = Series.defaultCountIterable;
        }
        if (config.values) {
            Series.checkIterable(config.values, "values");
            values = config.values;
        }
        else if (pairs) {
            values = new extract_element_iterable_1.ExtractElementIterable(pairs, 1);
        }
        else {
            values = Series.defaultEmptyIterable;
        }
        if (!pairs) {
            pairs = new multi_iterable_1.MultiIterable([index, values]);
        }
        if (config.baked !== undefined) {
            isBaked = config.baked;
        }
        return {
            index: index,
            values: values,
            pairs: pairs,
            isBaked: isBaked,
        };
    };
    //
    // Ensure the series content has been initialised.
    //
    Series.prototype.lazyInit = function () {
        if (this.content === null && this.configFn !== null) {
            this.content = Series.initFromConfig(this.configFn());
        }
    };
    //
    // Ensure the series content is lazy initalised and return it.
    //
    Series.prototype.getContent = function () {
        this.lazyInit();
        return this.content;
    };
    /**
     * Get an iterator to enumerate the values of the series.
     * Enumerating the iterator forces lazy evaluation to complete.
     * This function is automatically called by `for...of`.
     *
     * @return An iterator for the series.
     *
     * @example
     * <pre>
     *
     * for (const value of series) {
     *     // ... do something with the value ...
     * }
     * </pre>
     */
    Series.prototype[Symbol.iterator] = function () {
        return this.getContent().values[Symbol.iterator]();
    };
    /**
     * Cast the value of the series to a new type.
     * This operation has no effect but to retype the values that the series contains.
     *
     * @return The same series, but with the type changed.
     *
     * @example
     * <pre>
     *
     * const castSeries = series.cast<SomeOtherType>();
     * </pre>
     */
    Series.prototype.cast = function () {
        return this;
    };
    /**
     * Get the index for the series.
     *
     * @return The {@link Index} for the series.
     *
     * @example
     * <pre>
     *
     * const index = series.getIndex();
     * </pre>
     */
    Series.prototype.getIndex = function () {
        var _this = this;
        return new index_1.Index(function () { return ({ values: _this.getContent().index }); });
    };
    /**
     * Apply a new {@link Index} to the series.
     *
     * @param newIndex The new array or iterable to be the new {@link Index} of the series. Can also be a selector to choose the {@link Index} for each value in the series.
     *
     * @return Returns a new series with the specified {@link Index} attached.
     *
     * @example
     * <pre>
     *
     * const indexedSeries = series.withIndex([10, 20, 30]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const indexedSeries = series.withIndex(someOtherSeries);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const indexedSeries = series.withIndex(value => computeIndexFromValue(value));
     * </pre>
     *
     * @example
     * <pre>
     *
     * const indexedSeries = series.withIndex(value => value + 20);
     * </pre>
     */
    Series.prototype.withIndex = function (newIndex) {
        var _this = this;
        if (utils_1.isFunction(newIndex)) {
            return new Series(function () { return ({
                values: _this.getContent().values,
                index: _this.select(newIndex),
            }); });
        }
        else {
            Series.checkIterable(newIndex, 'newIndex');
            return new Series(function () { return ({
                values: _this.getContent().values,
                index: newIndex,
            }); });
        }
    };
    ;
    /**
     * Resets the {@link Index} of the series back to the default zero-based sequential integer index.
     *
     * @return Returns a new series with the {@link Index} reset to the default zero-based index.
     *
     * @example
     * <pre>
     *
     * const seriesWithResetIndex = series.resetIndex();
     * </pre>
     */
    Series.prototype.resetIndex = function () {
        var _this = this;
        return new Series(function () { return ({
            values: _this.getContent().values // Just strip the index.
        }); });
    };
    /**
     * Merge multiple series into a single series.
     * Values are merged by index.
     * Values at each index are combined into arrays in the resulting series.
     *
     * @param series An array or series of series to merge.
     *
     * @returns The merged series.
     *
     * @example
     * <pre>
     *
     * const mergedSeries = Series.merge([series1, series2, etc]);
     * </pre>
     */
    Series.merge = function (series) {
        var rowMap = new Map();
        var numSeries = Array.from(series).length; //TODO: Be nice not to have to do this.
        var seriesIndex = 0;
        try {
            for (var series_1 = __values(series), series_1_1 = series_1.next(); !series_1_1.done; series_1_1 = series_1.next()) {
                var workingSeries = series_1_1.value;
                try {
                    for (var _a = __values(workingSeries.toPairs()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var pair = _b.value;
                        var index = pair[0];
                        if (!rowMap.has(index)) {
                            rowMap.set(index, new Array(numSeries));
                        }
                        rowMap.get(index)[seriesIndex] = pair[1];
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                ++seriesIndex;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (series_1_1 && !series_1_1.done && (_d = series_1.return)) _d.call(series_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var mergedPairs = Array.from(rowMap.keys())
            .map(function (index) { return [index, rowMap.get(index)]; });
        mergedPairs.sort(function (a, b) {
            if (a[0] === b[0]) {
                return 0;
            }
            else if (a[0] > b[0]) {
                return 1;
            }
            else {
                return -1;
            }
        });
        return new Series({
            pairs: mergedPairs,
        });
        var e_2, _d, e_1, _c;
    };
    /**
      * Merge one or more series into this series.
      * Values are merged by index.
      * Values at each index are combined into arrays in the resulting series.
      *
      * @param series... One or more other series to merge into the series.
      *
      * @returns The merged series.
      *
      * @example
      * <pre>
      *
      * const mergedSeries = series1.merge(series2);
      * </pre>
      *
      * <pre>
      *
      * const mergedSeries = series1.merge(series2, series3, etc);
      * </pre>
      */
    Series.prototype.merge = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return Series.merge([this].concat(args));
    };
    /**
    * Extract values from the series as an array.
    * This forces lazy evaluation to complete.
    *
    * @return Returns an array of the values contained within the series.
    *
    * @example
    * <pre>
    * const values = series.toArray();
    * </pre>
    */
    Series.prototype.toArray = function () {
        var values = [];
        try {
            for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                if (value !== undefined) {
                    values.push(value);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return values;
        var e_3, _c;
    };
    /**
     * Retreive the index, values pairs from the series as an array.
     * Each pair is [index, value].
     * This forces lazy evaluation to complete.
     *
     * @return Returns an array of pairs that contains the series values. Each pair is a two element array that contains an index and a value.
     *
     * @example
     * <pre>
     * const pairs = series.toPairs();
     * </pre>
     */
    Series.prototype.toPairs = function () {
        var pairs = [];
        try {
            for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                var pair = _b.value;
                if (pair[1] != undefined) {
                    pairs.push(pair);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return pairs;
        var e_4, _c;
    };
    /**
     * Convert the series to a JavaScript object.
     *
     * @param keySelector User-defined selector function that selects keys for the resulting object.
     * @param valueSelector User-defined selector function that selects values for the resulting object.
     *
     * @return Returns a JavaScript object generated from the series by applying the key and value selector functions.
     *
     * @example
     * <pre>
     *
     * const someObject = series.toObject(
     *      value => value, // Specify the value to use for field names in the output object.
     *      value => value // Specify the value to use as the value for each field.
     * );
     * </pre>
     */
    Series.prototype.toObject = function (keySelector, valueSelector) {
        if (!utils_1.isFunction(keySelector))
            throw new Error("Expected 'keySelector' parameter to Series.toObject to be a function.");
        if (!utils_1.isFunction(valueSelector))
            throw new Error("Expected 'valueSelector' parameter to Series.toObject to be a function.");
        return utils_1.toMap(this, keySelector, valueSelector);
    };
    /**
     * Generates a new series by repeatedly calling a user-defined selector function on each value in the original series.
     *
     * @param selector A user-defined selector function that transforms each row to create the new dataframe.
     *
     * @return Returns a new series with each value transformed by the selector function.
     *
     * @example
     * <pre>
     *
     * function transformValue (inputValue) {
     *      const outputValue = {
     *          // ... construct output value derived from input value ...
     *      };
     *
     *      return outputValue;
     * }
     *
     * const transformedSeries = series.select(value => transformValue(value));
     * </pre>
     */
    Series.prototype.select = function (selector) {
        var _this = this;
        if (!utils_1.isFunction(selector))
            throw new Error("Expected 'selector' parameter to 'Series.select' function to be a function.");
        return new Series(function () { return ({
            values: new select_iterable_1.SelectIterable(_this.getContent().values, selector),
            index: _this.getContent().index,
        }); });
    };
    /**
     * Generates a new series by repeatedly calling a user-defined selector function on each row in the original series.
     *
     * Similar to the {@link select} function, but in this case the selector function produces a collection of output values that are flattened and merged to create the new series.
     *
     * @param selector A user-defined selector function that transforms each value into a collection of output values.
     *
     * @return Returns a new series where each value has been transformed into 0 or more new values by the selector function.
     *
     * @example
     * <pre>
     *
     * function produceOutputValues (inputValue) {
     *      const outputValues = [];
     *      while (someCondition) {
     *          // ... generate zero or more output values ...
     *          outputValues.push(... some generated value ...);
     *      }
     *      return outputValues;
     * }
     *
     * const modifiedSeries = series.selectMany(value => produceOutputValues(value));
     * </pre>
     */
    Series.prototype.selectMany = function (selector) {
        var _this = this;
        if (!utils_1.isFunction(selector))
            throw new Error("Expected 'selector' parameter to 'Series.selectMany' to be a function.");
        return new Series(function () { return ({
            pairs: new select_many_iterable_1.SelectManyIterable(_this.getContent().pairs, function (pair, index) {
                var outputPairs = [];
                try {
                    for (var _a = __values(selector(pair[1], index)), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var transformed = _b.value;
                        outputPairs.push([
                            pair[0],
                            transformed
                        ]);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                return outputPairs;
                var e_5, _c;
            })
        }); });
    };
    /**
     * Partition a series into a {@link Series} of *data windows*.
     * Each value in the new series is a chunk of data from the original series.
     *
     * @param period The number of values to include in each data window.
     *
     * @return Returns a new series, each value of which is a chunk (data window) of the original series.
     *
     * @example
     * <pre>
     *
     * const windows = series.window(2); // Get values in pairs.
     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());
     * console.log(pctIncrease.toString());
     * </pre>
     *
     * @example
     * <pre>
     *
     * const salesDf = ... // Daily sales data.
     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.
     * console.log(weeklySales.toString());
     * </pre>
     */
    Series.prototype.window = function (period) {
        var _this = this;
        if (!utils_1.isNumber(period))
            throw new Error("Expected 'period' parameter to 'Series.window' to be a number.");
        return new Series(function () { return ({
            values: new series_window_iterable_1.SeriesWindowIterable(_this.getContent().pairs, period)
        }); });
    };
    /**
     * Partition a series into a new series of *rolling data windows*.
     * Each value in the new series is a rolling chunk of data from the original series.
     *
     * @param period The number of data values to include in each data window.
     *
     * @return Returns a new series, each value of which is a rolling chunk of the original series.
     *
     * @example
     * <pre>
     *
     * const salesData = ... // Daily sales data.
     * const rollingWeeklySales = salesData.rollingWindow(7); // Get rolling window over weekly sales data.
     * console.log(rollingWeeklySales.toString());
     * </pre>
     */
    Series.prototype.rollingWindow = function (period) {
        var _this = this;
        if (!utils_1.isNumber(period))
            throw new Error("Expected 'period' parameter to 'Series.rollingWindow' to be a number.");
        return new Series(function () { return ({
            values: new series_rolling_window_iterable_1.SeriesRollingWindowIterable(_this.getContent().pairs, period)
        }); });
    };
    /**
     * Partition a series into a new series of variable-length *data windows*
     * where the divisions between the data chunks are
     * defined by a user-provided *comparer* function.
     *
     * @param comparer Function that compares two adjacent data values and returns true if they should be in the same window.
     *
     * @return Returns a new series, each value of which is a chunk of data from the original series.
     *
     * @example
     * <pre>
     *
     * function rowComparer (valueA, valueB) {
     *      if (... valueA should be in the same data window as valueB ...) {
     *          return true;
     *      }
     *      else {
     *          return false;
     *      }
     * };
     *
     * const variableWindows = series.variableWindow(rowComparer);
     */
    Series.prototype.variableWindow = function (comparer) {
        var _this = this;
        if (!utils_1.isFunction(comparer))
            throw new Error("Expected 'comparer' parameter to 'Series.variableWindow' to be a function.");
        return new Series(function () { return ({
            values: new series_variable_window_iterable_1.SeriesVariableWindowIterable(_this.getContent().pairs, comparer)
        }); });
    };
    ;
    /**
     * Eliminates adjacent duplicate values.
     *
     * For each group of adjacent values that are equivalent only returns the last index/row for the group,
     * thus ajacent equivalent values are collapsed down to the last value.
     *
     * @param [selector] Optional selector function to determine the value used to compare for equivalence.
     *
     * @return Returns a new series with groups of adjacent duplicate vlaues collapsed to a single value per group.
     *
     * @example
     * <pre>
     *
     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value);
     *
     * // Or
     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value.someNestedField);
     * </pre>
     */
    Series.prototype.sequentialDistinct = function (selector) {
        if (selector) {
            if (!utils_1.isFunction(selector))
                throw new Error("Expected 'selector' parameter to 'Series.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.");
        }
        else {
            selector = function (value) { return value; };
        }
        return this.variableWindow(function (a, b) { return selector(a) === selector(b); })
            .select(function (window) {
            return [window.getIndex().first(), window.first()];
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Aggregate the values in the series to a single result.
     *
     * @param [seed] Optional seed value for producing the aggregation.
     * @param selector Function that takes the seed and then each value in the series and produces the aggregated value.
     *
     * @return Returns a new value that has been aggregated from the series using the 'selector' function.
     *
     * @example
     * <pre>
     *
     * const dailySales = ... daily sales figures for the past month ...
     * const totalSalesForthisMonth = dailySales.aggregate(
     *      0, // Seed - the starting value.
     *      (accumulator, salesAmount) => accumulator + salesAmount // Aggregation function.
     * );
     * </pre>
     *
     * @example
     * <pre>
     *
     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.
     * const dailySales = ... daily sales figures for the past month ...
     * const updatedTotalSalesAllTime = dailySales.aggregate(
     *      totalSalesAllTime,
     *      (accumulator, salesAmount) => accumulator + salesAmount
     * );
     * </pre>
     *
     * @example
     * <pre>
     *
     * var salesDataSummary = salesData.aggregate({
     *      TotalSales: series => series.count(),
     *      AveragePrice: series => series.average(),
     *      TotalRevenue: series => series.sum(),
     * });
     * </pre>
    */
    Series.prototype.aggregate = function (seedOrSelector, selector) {
        if (utils_1.isFunction(seedOrSelector) && !selector) {
            return this.skip(1).aggregate(this.first(), seedOrSelector);
        }
        else {
            if (!utils_1.isFunction(selector))
                throw new Error("Expected 'selector' parameter to aggregate to be a function.");
            var accum = seedOrSelector;
            try {
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    accum = selector(accum, value);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_6) throw e_6.error; }
            }
            return accum;
        }
        var e_6, _c;
    };
    /**
     * Compute the amount of change between pairs or sets of values in the series.
     *
     * @param [period] Optional period for computing the change - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the amount of change from the previous number value in the original series.
     *
     * @example
     * <pre>
     *
     * const saleFigures = ... running series of daily sales figures ...
     * const amountChanged = salesFigures.amountChanged(); // Amount that sales has changed, day to day.
     * </pre>
     * @example
     * <pre>
     *
     * const saleFigures = ... running series of daily sales figures ...
     * const amountChanged = salesFigures.amountChanged(7); // Amount that sales has changed, week to week.
     * </pre>
     */
    Series.prototype.amountChange = function (period) {
        return this // Have to assume this is a number series.
            .rollingWindow(period === undefined ? 2 : period)
            .select(function (window) {
            var first = window.first();
            var last = window.last();
            var amountChange = last - first; // Compute amount of change.
            return [window.getIndex().last(), amountChange]; // Return new index and value.
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Compute the proportion change between pairs or sets of values in the series.
     * Proportions are expressed as 0-1 values.
     *
     * @param [period] Optional period for computing the proportion - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.
     *
     * @example
     * <pre>
     *
     * const saleFigures = ... running series of daily sales figures ...
     * const proportionChanged = salesFigures.amountChanged(); // Proportion that sales has changed, day to day.
     * </pre>
     * @example
     * <pre>
     *
     * const saleFigures = ... running series of daily sales figures ...
     * const proportionChanged = salesFigures.amountChanged(7); // Proportion that sales has changed, week to week.
     * </pre>
     */
    Series.prototype.proportionChange = function (period) {
        return this // Have to assume this is a number series.
            .rollingWindow(period === undefined ? 2 : period)
            .select(function (window) {
            var first = window.first();
            var last = window.last();
            var amountChange = last - first; // Compute amount of change.
            var pctChange = amountChange / first; // Compute proportion change.
            return [window.getIndex().last(), pctChange]; // Return new index and value.
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Compute the percentage change between pairs or sets of values in the series.
     * Percentages are expressed as 0-100 values.
     *
     * @param [period] Optional period for computing the percentage - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the percent change from the previous number value in the original series.
     *
     * @example
     * <pre>
     *
     * const saleFigures = ... running series of daily sales figures ...
     * const percentChanged = salesFigures.amountChanged(); // Percent that sales has changed, day to day.
     * </pre>
     * @example
     * <pre>
     *
     * const saleFigures = ... running series of daily sales figures ...
     * const percentChanged = salesFigures.amountChanged(7); // Percent that sales has changed, week to week.
     * </pre>
     */
    Series.prototype.percentChange = function (period) {
        return this.proportionChange(period).select(function (v) { return v * 100; });
    };
    /**
     * For each period, compute the proportion of values that are less than the last value in the period.
     * Proportions are expressed as 0-1 values.
     *
     * @param [period] Optional period for computing the proportion rank - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the proportion rank value for that period.
     *
     * @example
     * <pre>
     *
     * const proportionRank = series.proportionRank();
     * </pre>
     * @example
     * <pre>
     *
     * const proportionRank = series.proportionRank(100);
     * </pre>
     */
    Series.prototype.proportionRank = function (period) {
        if (period === undefined) {
            period = 2;
        }
        if (!utils_1.isNumber(period)) {
            throw new Error("Expected 'period' parameter to 'Series.proportionRank' to be a number that specifies the time period for the ranking.");
        }
        return this.rollingWindow(period + 1) // +1 to account for the last value being used.
            .select(function (window) {
            var latestValue = window.last();
            var numLowerValues = window.head(-1).where(function (prevMomentum) { return prevMomentum < latestValue; }).count();
            var proportionRank = numLowerValues / period;
            return [
                window.getIndex().last(),
                proportionRank
            ];
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * For each period, compute the percent of values that are less than the last value in the period.
     * Percent are expressed as 0-100 values.
     *
     * @param [period] Optional period for computing the percent rank - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the percent rank value for that period.
     *
     * @example
     * <pre>
     *
     * const percentRank = series.percentRank();
     * </pre>
     * @example
     * <pre>
     *
     * const percentRank = series.percentRank(100);
     * </pre>
     */
    Series.prototype.percentRank = function (period) {
        if (period === undefined) {
            period = 2;
        }
        if (!utils_1.isNumber(period)) {
            throw new Error("Expected 'period' parameter to 'Series.percentRank' to be a number that specifies the time period for the ranking.");
        }
        return this.proportionRank(period).select(function (proportion) { return proportion * 100; });
    };
    /**
     * Skip a number of values in the series.
     *
     * @param numValues Number of values to skip.
     *
     * @return Returns a new series with the specified number of values skipped.
     *
     * @example
     * <pre>
     *
     * const seriesWithRowsSkipped = series.skip(10); // Skip 10 rows in the original series.
     * </pre>
     */
    Series.prototype.skip = function (numValues) {
        var _this = this;
        return new Series(function () { return ({
            values: new skip_iterable_1.SkipIterable(_this.getContent().values, numValues),
            index: new skip_iterable_1.SkipIterable(_this.getContent().index, numValues),
            pairs: new skip_iterable_1.SkipIterable(_this.getContent().pairs, numValues),
        }); });
    };
    /**
     * Skips values in the series while a condition evaluates to true or truthy.
     *
     * @param predicate Returns true/truthy to continue to skip values in the original series.
     *
     * @return Returns a new series with all initial sequential values removed while the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const seriesWithRowsSkipped = series.skipWhile(salesFigure => salesFigure > 100); // Skip initial sales figure that are less than 100.
     * </pre>
     */
    Series.prototype.skipWhile = function (predicate) {
        var _this = this;
        if (!utils_1.isFunction(predicate))
            throw new Error("Expected 'predicate' parameter to 'Series.skipWhile' function to be a predicate function that returns true/false.");
        return new Series(function () { return ({
            values: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().values, predicate),
            pairs: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().pairs, function (pair) { return predicate(pair[1]); }),
        }); });
    };
    /**
     * Skips values in the series untils a condition evaluates to true or truthy.
     *
     * @param predicate Return true/truthy to stop skipping values in the original series.
     *
     * @return Returns a new series with all initial sequential values removed until the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const seriesWithRowsSkipped = series.skipUntil(salesFigure => salesFigure > 100); // Skip initial sales figures unitl we see one greater than 100.
     * </pre>
     */
    Series.prototype.skipUntil = function (predicate) {
        if (!utils_1.isFunction(predicate))
            throw new Error("Expected 'predicate' parameter to 'Series.skipUntil' function to be a predicate function that returns true/false.");
        return this.skipWhile(function (value) { return !predicate(value); });
    };
    /**
     * Take a number of  values from the series.
     *
     * @param numValues Number of values to take.
     *
     * @return Returns a new series with only the specified number of values taken from the original series.
     *
     * @example
     * <pre>
     *
     * const seriesWithRowsTaken = series.take(15); // Take only the first 15 values from the original series.
     * </pre>
     */
    Series.prototype.take = function (numRows) {
        var _this = this;
        if (!utils_1.isNumber(numRows))
            throw new Error("Expected 'numRows' parameter to 'Series.take' function to be a number.");
        return new Series(function () { return ({
            index: new take_iterable_1.TakeIterable(_this.getContent().index, numRows),
            values: new take_iterable_1.TakeIterable(_this.getContent().values, numRows),
            pairs: new take_iterable_1.TakeIterable(_this.getContent().pairs, numRows)
        }); });
    };
    ;
    /**
     * Takes values from the series while a condition evaluates to true or truthy.
     *
     * @param predicate Returns true/truthy to continue to take values from the original series.
     *
     * @return Returns a new series with only the initial sequential values that were taken while the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const seriesWithRowsTaken = series.takeWhile(salesFigure => salesFigure > 100); // Take only initial sales figures that are greater than 100.
     * </pre>
     */
    Series.prototype.takeWhile = function (predicate) {
        var _this = this;
        if (!utils_1.isFunction(predicate))
            throw new Error("Expected 'predicate' parameter to 'Series.takeWhile' function to be a predicate function that returns true/false.");
        return new Series(function () { return ({
            values: new take_while_iterable_1.TakeWhileIterable(_this.getContent().values, predicate),
            pairs: new take_while_iterable_1.TakeWhileIterable(_this.getContent().pairs, function (pair) { return predicate(pair[1]); })
        }); });
    };
    /**
     * Takes values from the series until a condition evaluates to true or truthy.
     *
     * @param predicate Return true/truthy to stop taking values in the original series.
     *
     * @return Returns a new series with only the initial sequential values taken until the predicate returned true/truthy.
     *
     * @example
     * <pre>
     *
     * const seriesWithRowsTaken = series.takeUntil(salesFigure => salesFigure > 100); // Take all initial sales figures until we see one that is greater than 100.
     * </pre>
     */
    Series.prototype.takeUntil = function (predicate) {
        if (!utils_1.isFunction(predicate))
            throw new Error("Expected 'predicate' parameter to 'Series.takeUntil' function to be a predicate function that returns true/false.");
        return this.takeWhile(function (value) { return !predicate(value); });
    };
    /**
     * Static version of the count function for use with summarize and pivot functions.
     *
     * @param series Input series to be counted.
     *
     * @returns Returns the count of values in the series.
     *
     * @example
     * <pre>
     *
     * const summary = dataFrame.summarize({
     *      ColumnToBeCounted: Series.count,
     * });
     * </pre>
     */
    Series.count = function (series) {
        return series.count();
    };
    /**
     * Count the number of values in the seriese
     *
     * @return Returns the count of all values.
     *
     * @example
     * <pre>
     *
     * const numValues = series.count();
     * </pre>
     */
    Series.prototype.count = function () {
        var total = 0;
        try {
            for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                ++total;
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return total;
        var e_7, _c;
    };
    /**
     * Get the first value of the series.
     *
     * @return Returns the first value of the series.
     *
     * @example
     * <pre>
     *
     * const firstValue = series.first();
     * </pre>
     */
    Series.prototype.first = function () {
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                return value; // Only need the first value.
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_8) throw e_8.error; }
        }
        throw new Error("Series.first: No values in Series.");
        var e_8, _c;
    };
    /**
     * Get the last value of the series.
     *
     * @return Returns the last value of the series.
     *
     * @example
     * <pre>
     *
     * const lastValue = series.last();
     * </pre>
     */
    Series.prototype.last = function () {
        var lastValue = null;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                lastValue = value; // Throw away all values until we get to the last one.
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_9) throw e_9.error; }
        }
        if (lastValue === null) {
            throw new Error("Series.last: No values in Series.");
        }
        return lastValue;
        var e_9, _c;
    };
    /**
     * Get the value, if there is one, with the specified index.
     *
     * @param index Index to for which to retreive the value.
     *
     * @return Returns the value from the specified index in the series or undefined if there is no such index in the present in the series.
     *
     * @example
     * <pre>
     *
     * const value = series.at(5); // Get the value at index 5 (with a default 0-based index).
     * </pre>
     *
     * @example
     * <pre>
     *
     * const date = ... some date ...
     * // Retreive the value with specified date from a time-series (assuming date indexed has been applied).
     * const value = series.at(date);
     * </pre>
     */
    Series.prototype.at = function (index) {
        if (this.none()) {
            return undefined;
        }
        try {
            //
            // This is pretty expensive.
            // A specialised index could improve this.
            //
            for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                var pair = _b.value;
                if (pair[0] === index) {
                    return pair[1];
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_10) throw e_10.error; }
        }
        return undefined;
        var e_10, _c;
    };
    /**
     * Get X value from the start of the series.
     * Pass in a negative value to get all values at the head except for X values at the tail.
     *
     * @param numValues Number of values to take.
     *
     * @return Returns a new series that has only the specified number of values taken from the start of the original series.
     *
     * @examples
     * <pre>
     *
     * const sample = series.head(10); // Take a sample of 10 values from the start of the series.
     * </pre>
     */
    Series.prototype.head = function (numValues) {
        if (!utils_1.isNumber(numValues))
            throw new Error("Expected 'numValues' parameter to 'Series.head' function to be a number.");
        if (numValues === 0) {
            return new Series(); // Empty series.
        }
        var toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;
        return this.take(toTake);
    };
    /**
     * Get X values from the end of the series.
     * Pass in a negative value to get all values at the tail except X values at the head.
     *
     * @param numValues Number of values to take.
     *
     * @return Returns a new series that has only the specified number of values taken from the end of the original series.
     *
     * @examples
     * <pre>
     *
     * const sample = series.tail(12); // Take a sample of 12 values from the end of the series.
     * </pre>
     */
    Series.prototype.tail = function (numValues) {
        if (!utils_1.isNumber(numValues))
            throw new Error("Expected 'numValues' parameter to 'Series.tail' function to be a number.");
        if (numValues === 0) {
            return new Series(); // Empty series.
        }
        var toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);
        return this.skip(toSkip);
    };
    /**
     * Filter the series using user-defined predicate function.
     *
     * @param predicate Predicte function to filter values from the series. Returns true/truthy to keep values, or false/falsy to omit values.
     *
     * @return Returns a new series containing only the values from the original series that matched the predicate.
     *
     * @example
     * <pre>
     *
     * const filtered = series.where(salesFigure => salesFigure > 100); // Filter so we only have sales figures greater than 100.
     * </pre>
     */
    Series.prototype.where = function (predicate) {
        var _this = this;
        if (!utils_1.isFunction(predicate))
            throw new Error("Expected 'predicate' parameter to 'Series.where' function to be a function.");
        return new Series(function () { return ({
            values: new where_iterable_1.WhereIterable(_this.getContent().values, predicate),
            pairs: new where_iterable_1.WhereIterable(_this.getContent().pairs, function (pair) { return predicate(pair[1]); })
        }); });
    };
    /**
     * Invoke a callback function for each value in the series.
     *
     * @param callback The calback function to invoke for each value.
     *
     * @return Returns the original series with no modifications.
     *
     * @example
     * <pre>
     *
     * series.forEach(value => {
     *      // ... do something with the value ...
     * });
     * </pre>
     */
    Series.prototype.forEach = function (callback) {
        if (!utils_1.isFunction(callback))
            throw new Error("Expected 'callback' parameter to 'Series.forEach' to be a function.");
        var index = 0;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                callback(value, index++);
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_11) throw e_11.error; }
        }
        return this;
        var e_11, _c;
    };
    ;
    /**
     * Evaluates a predicate function for every value in the series to determine
     * if some condition is true/truthy for **all** values in the series.
     *
     * @param predicate Predicate function that receives each value. It should returns true/truthy for a match, otherwise false/falsy.
     *
     * @return Returns true if the predicate has returned true or truthy for every value in the series, otherwise returns false. Returns false for an empty series.
     *
     * @example
     * <pre>
     *
     * const result = series.all(salesFigure => salesFigure > 100); // Returns true if all sales figures are greater than 100.
     * </pre>
     */
    Series.prototype.all = function (predicate) {
        if (!utils_1.isFunction(predicate))
            throw new Error("Expected 'predicate' parameter to 'Series.all' to be a function.");
        var count = 0;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                if (!predicate(value)) {
                    return false;
                }
                ++count;
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_12) throw e_12.error; }
        }
        return count > 0;
        var e_12, _c;
    };
    /**
     * Evaluates a predicate function for every value in the series to determine
     * if some condition is true/truthy for **any** of values in the series.
     *
     * If no predicate is specified then it simply checks if the series contains more than zero values.
     *
     * @param [predicate] Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.
     *
     * @return Returns true if the predicate has returned truthy for any value in the series, otherwise returns false.
     * If no predicate is passed it returns true if the series contains any values at all.
     * Returns false for an empty series.
     *
     * @example
     * <pre>
     *
     * const result = series.any(salesFigure => salesFigure > 100); // Do we have any sales figures greater than 100?
     * </pre>
     *
     * @example
     * <pre>
     *
     * const result = series.any(); // Do we have any sales figures at all?
     * </pre>
     */
    Series.prototype.any = function (predicate) {
        if (predicate) {
            if (!utils_1.isFunction(predicate))
                throw new Error("Expected 'predicate' parameter to 'Series.any' to be a function.");
        }
        if (predicate) {
            try {
                // Use the predicate to check each value.
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    if (predicate(value)) {
                        return true;
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_13) throw e_13.error; }
            }
        }
        else {
            // Just check if there is at least one item.
            var iterator = this[Symbol.iterator]();
            return !iterator.next().done;
        }
        return false; // Nothing passed.
        var e_13, _c;
    };
    /**
     * Evaluates a predicate function for every value in the series to determine
     * if some condition is true/truthy for **none** of values in the series.
     *
     * If no predicate is specified then it simply checks if the series contains zero values.
     *
     * @param [predicate] Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.
     *
     * @return Returns true if the predicate has returned truthy for zero values in the series, otherwise returns false. Returns false for an empty series.
     *
     * @example
     * <pre>
     *
     * const result = series.none(salesFigure => salesFigure > 100); // Do we have zero sales figures greater than 100?
     * </pre>
     *
     * @example
     * <pre>
     *
     * const result = series.none(); // Do we have zero sales figures?
     * </pre>
     */
    Series.prototype.none = function (predicate) {
        if (predicate) {
            if (!utils_1.isFunction(predicate))
                throw new Error("Expected 'predicate' parameter to 'Series.none' to be a function.");
        }
        if (predicate) {
            try {
                // Use the predicate to check each value.
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    if (predicate(value)) {
                        return false;
                    }
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_14) throw e_14.error; }
            }
        }
        else {
            // Just check if empty.
            var iterator = this[Symbol.iterator]();
            return iterator.next().done;
        }
        return true; // Nothing failed the predicate.
        var e_14, _c;
    };
    /**
     * Gets a new series containing all values starting at or after the specified index value.
     *
     * @param indexValue The index value at which to start the new series.
     *
     * @return Returns a new series containing all values starting at or after the specified index value.
     *
     * @example
     * <pre>
     *
     * const series = new Series({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const lastHalf = series.startAt(2);
     * expect(lastHalf.toArray()).to.eql([30, 40]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeries = ... a series indexed by date/time ...
     *
     * // Get all values starting at (or after) a particular date.
     * const result = timeSeries.startAt(new Date(2016, 5, 4));
     * </pre>
     */
    Series.prototype.startAt = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThan = _this.getIndex().getLessThan();
            return {
                index: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().index, function (index) { return lessThan(index, indexValue); }),
                pairs: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().pairs, function (pair) { return lessThan(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Gets a new series containing all values up until and including the specified index value (inclusive).
     *
     * @param indexValue The index value at which to end the new series.
     *
     * @return Returns a new series containing all values up until and including the specified index value.
     *
     * @example
     * <pre>
     *
     * const series = new Series({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const firstHalf = series.endAt(1);
     * expect(firstHalf.toArray()).to.eql([10, 20]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeries = ... a series indexed by date/time ...
     *
     * // Get all values ending at a particular date.
     * const result = timeSeries.endAt(new Date(2016, 5, 4));
     * </pre>
     */
    Series.prototype.endAt = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();
            return {
                index: new take_while_iterable_1.TakeWhileIterable(_this.getContent().index, function (index) { return lessThanOrEqualTo(index, indexValue); }),
                pairs: new take_while_iterable_1.TakeWhileIterable(_this.getContent().pairs, function (pair) { return lessThanOrEqualTo(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Gets a new series containing all values up to the specified index value (exclusive).
     *
     * @param indexValue The index value at which to end the new series.
     *
     * @return Returns a new series containing all values up to (but not including) the specified index value.
     *
     * @example
     * <pre>
     *
     * const series = new Series({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const firstHalf = series.before(2);
     * expect(firstHalf.toArray()).to.eql([10, 20]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeries = ... a series indexed by date/time ...
     *
     * // Get all values before the specified date.
     * const result = timeSeries.before(new Date(2016, 5, 4));
     * </pre>
     */
    Series.prototype.before = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThan = _this.getIndex().getLessThan();
            return {
                index: new take_while_iterable_1.TakeWhileIterable(_this.getContent().index, function (index) { return lessThan(index, indexValue); }),
                pairs: new take_while_iterable_1.TakeWhileIterable(_this.getContent().pairs, function (pair) { return lessThan(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Gets a new series containing all values after the specified index value (exclusive).
     *
     * @param indexValue The index value after which to start the new series.
     *
     * @return Returns a new series containing all values after the specified index value.
     *
     * @example
     * <pre>
     *
     * const series = new Series({
     *      index: [0, 1, 2, 3], // This is the default index.
     *      values: [10, 20, 30, 40],
     * });
     *
     * const lastHalf = df.before(1);
     * expect(lastHalf.toArray()).to.eql([30, 40]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSerie = ... a series indexed by date/time ...
     *
     * // Get all values after the specified date.
     * const result = timeSeries.after(new Date(2016, 5, 4));
     * </pre>
     */
    Series.prototype.after = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();
            return {
                index: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().index, function (index) { return lessThanOrEqualTo(index, indexValue); }),
                pairs: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().pairs, function (pair) { return lessThanOrEqualTo(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Gets a new series containing all values between the specified index values (inclusive).
     *
     * @param startIndexValue The index at which to start the new series.
     * @param endIndexValue The index at which to end the new series.
     *
     * @return Returns a new series containing all values between the specified index values (inclusive).
     *
     * @example
     * <pre>
     *
     * const series = new Series({
     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.
     *      values: [10, 20, 30, 40, 50, 60],
     * });
     *
     * const middleSection = series.between(1, 4);
     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const timeSeries = ... a series indexed by date/time ...
     *
     * // Get all values between the start and end dates (inclusive).
     * const result = timeSeries.after(new Date(2016, 5, 4), new Date(2016, 5, 22));
     * </pre>
     */
    Series.prototype.between = function (startIndexValue, endIndexValue) {
        return this.startAt(startIndexValue).endAt(endIndexValue);
    };
    /**
     * Format the series for display as a string.
     * This forces lazy evaluation to complete.
     *
     * @return Generates and returns a string representation of the series.
     *
     * @example
     * <pre>
     *
     * console.log(series.toString());
     * </pre>
     */
    Series.prototype.toString = function () {
        var header = ["__index__", "__value__"];
        var rows = this.toPairs();
        var table = new easy_table_1.default();
        for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {
            var row = rows[rowIndex];
            for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {
                var cell = row[cellIndex];
                table.cell(header[cellIndex], cell);
            }
            table.newRow();
        }
        return table.toString();
    };
    ;
    //
    // Helper function to parse a string to an int.
    //
    Series.parseInt = function (value, valueIndex) {
        if (value === undefined) {
            return undefined;
        }
        else {
            if (!utils_1.isString(value))
                throw new Error("Called Series.parseInts, expected all values in the series to be strings, instead found a '" + typeof (value) + "' at index " + valueIndex);
            if (value.length === 0) {
                return undefined;
            }
            return parseInt(value);
        }
    };
    /**
     * Parse a series with string values and convert it to a series with int values.
     *
     * @return Returns a new series with values parsed from strings to ints.
     *
     * @example
     * <pre>
     *
     * const parsed = series.parseInts();
     * </pre>
     */
    Series.prototype.parseInts = function () {
        return this.select(Series.parseInt);
    };
    ;
    //
    // Helper function to parse a string to a float.
    //
    Series.parseFloat = function (value, valueIndex) {
        if (value === undefined) {
            return undefined;
        }
        else {
            if (!utils_1.isString(value))
                throw new Error("Called Series.parseFloats, expected all values in the series to be strings, instead found a '" + typeof (value) + "' at index " + valueIndex);
            if (value.length === 0) {
                return undefined;
            }
            return parseFloat(value);
        }
    };
    /**
     * Parse a series with string values and convert it to a series with float values.
     *
     * @return Returns a new series with values parsed from strings to floats.
     *
     * @example
     * <pre>
     *
     * const parsed = series.parseFloats();
     * </pre>
     */
    Series.prototype.parseFloats = function () {
        return this.select(Series.parseFloat);
    };
    ;
    //
    // Helper function to parse a string to a date.
    //
    Series.parseDate = function (value, valueIndex, formatString) {
        if (value === undefined) {
            return undefined;
        }
        else {
            if (!utils_1.isString(value))
                throw new Error("Called Series.parseDates, expected all values in the series to be strings, instead found a '" + typeof (value) + "' at index " + valueIndex);
            if (value.length === 0) {
                return undefined;
            }
            return dayjs_1.default(value, formatString).toDate();
        }
    };
    /**
     * Parse a series with string values and convert it to a series with date values.
     *
     * @param [formatString] Optional formatting string for dates.
     *
     * Moment is used for date parsing.
     * https://momentjs.com
     *
     * @return Returns a new series with values parsed from strings to dates.
     *
     * @example
     * <pre>
     *
     * const parsed = series.parseDates();
     * </pre>
     */
    Series.prototype.parseDates = function (formatString) {
        if (formatString) {
            if (!utils_1.isString(formatString))
                throw new Error("Expected optional 'formatString' parameter to Series.parseDates to be a string (if specified).");
        }
        return this.select(function (value, valueIndex) { return Series.parseDate(value, valueIndex, formatString); });
    };
    //
    // Helper function to convert a value to a string.
    //
    Series.toString = function (value, formatString) {
        if (value === undefined) {
            return undefined;
        }
        else if (value === null) {
            return null;
        }
        else if (formatString && utils_1.isDate(value)) {
            return dayjs_1.default(value).format(formatString);
        }
        else if (formatString && utils_1.isNumber(value)) {
            return numeral_1.default(value).format(formatString);
        }
        else {
            return value.toString();
        }
    };
    /**
     * Convert a series of values of different types to a series containing string values.
     *
     * @param [formatString] Optional formatting string for dates.
     *
     * Numeral.js is used for number formatting.
     * http://numeraljs.com/
     *
     * Moment is used for date formatting.
     * https://momentjs.com/docs/#/parsing/string-format/
     *
     * @return Returns a new series values converted from values to strings.
     *
     * @example
     * <pre>
     *
     * const result = series.toStrings("YYYY-MM-DD");
     * </pre>
     *
     * @example
     * <pre>
     *
     * const result = series.toStrings("0.00");
     * </pre>
     */
    Series.prototype.toStrings = function (formatString) {
        if (formatString) {
            if (!utils_1.isString(formatString))
                throw new Error("Expected optional 'formatString' parameter to Series.toStrings to be a string (if specified).");
        }
        return this.select(function (value) { return Series.toString(value, formatString); });
    };
    /**
     * Forces lazy evaluation to complete and 'bakes' the series into memory.
     *
     * @return Returns a series that has been 'baked', all lazy evaluation has completed.
     *
     * @example
     * <pre>
     *
     * const baked = series.bake();
     * </pre>
     */
    Series.prototype.bake = function () {
        if (this.getContent().isBaked) {
            // Already baked.
            return this;
        }
        return new Series({
            values: this.toArray(),
            pairs: this.toPairs(),
            baked: true,
        });
    };
    ;
    /**
     * Converts (inflates) a series to a {@link DataFrame}.
     *
     * @param [selector] Optional user-defined selector function that transforms each value to produce the dataframe.
     *
     * @returns Returns a dataframe that was created from the original series.
     *
     * @example
     * <pre>
     *
     * const dataframe = series.inflate(); // Inflate a series of objects to a dataframe.
     * </pre>
     *
     * @example
     * <pre>
     *
     * const dataframe = series.inflate(value => { AColumn:  value }); // Produces a dataframe with 1 column from a series of values.
     * </pre>
     *
     * @example
     * <pre>
     *
     * const dataframe = series.inflate(value => { AColumn:  value.NestedValue }); // Extract a nested value and produce a dataframe from it.
     * </pre>
     */
    Series.prototype.inflate = function (selector) {
        var _this = this;
        if (selector) {
            if (!utils_1.isFunction(selector))
                throw new Error("Expected 'selector' parameter to Series.inflate to be a selector function.");
            return new dataframe_1.DataFrame(function () {
                var content = _this.getContent();
                return {
                    values: new select_iterable_1.SelectIterable(content.values, selector),
                    index: content.index,
                    pairs: new select_iterable_1.SelectIterable(content.pairs, function (pair, index) { return [pair[0], selector(pair[1], index)]; }),
                };
            });
        }
        else {
            return new dataframe_1.DataFrame(function () {
                var content = _this.getContent();
                return {
                    values: content.values,
                    index: content.index,
                    pairs: content.pairs,
                };
            });
        }
    };
    /**
     * Static version of the sum function for use with summarize and pivot functions.
     *
     * @param series Input series to be summed.
     *
     * @returns Returns the sum of the number values in the series.
     *
     * @example
     * <pre>
     *
     * const summary = dataFrame.summarize({
     *      ColumnToBeSummed: Series.sum,
     * });
     * </pre>
     */
    Series.sum = function (series) {
        return series.sum();
    };
    /**
     * Sum the values in a series and returns the result.
     *
     * @returns Returns the sum of the number values in the series.
     *
     * @example
     * <pre>
     *
     * const totalSales = salesFigures.sum();
     * </pre>
     */
    Series.prototype.sum = function () {
        if (this.none()) {
            return 0;
        }
        var numberSeries = this; // Have to assume we are working with a number series here.
        return numberSeries.aggregate(function (prev, value) { return prev + value; });
    };
    /**
     * Static version of the average function for use with summarize and pivot functions.
     *
     * @param series Input series to be averaged.
     *
     * @returns Returns the average of the number values in the series.
     *
     * @example
     * <pre>
     *
     * const summary = dataFrame.summarize({
     *      ColumnToBeAveraged: Series.average,
     * });
     * </pre>
     */
    Series.average = function (series) {
        return series.average();
    };
    /**
     * Average the values in a series and returns the result
     *
     * @returns Returns the average of the number values in the series.
     *
     * @example
     * <pre>
     *
     * const averageSales = salesFigures.average();
     * </pre>
     */
    Series.prototype.average = function () {
        var count = this.count();
        if (count > 0) {
            return this.sum() / count;
        }
        else {
            return 0;
        }
    };
    /**
     * Static version of the median function for use with summarize and pivot functions.
     *
     * @param series Input series to find the median of.
     *
     * @returns Returns the median of the number values in the series.
     *
     * @example
     * <pre>
     *
     * const summary = dataFrame.summarize({
     *      InputColumn: Series.median,
     * });
     * </pre>
     */
    Series.median = function (series) {
        return series.median();
    };
    /**
     * Get the median value in the series.
     * Note that this sorts the series, which can be expensive.
     *
     * @returns Returns the median of the values in the series.
     *
     * @example
     * <pre>
     *
     * const medianSales = salesFigures.median();
     * </pre>
     */
    Series.prototype.median = function () {
        //
        // From here: http://stackoverflow.com/questions/5275115/add-a-median-method-to-a-list
        //
        var numberSeries = this; // Have to assume we are working with a number series here.
        var count = numberSeries.count();
        if (count === 0) {
            return 0;
        }
        var ordered = numberSeries.orderBy(function (value) { return value; }).toArray();
        if ((count % 2) == 0) {
            // Even.
            var a = ordered[count / 2 - 1];
            var b = ordered[count / 2];
            return (a + b) / 2;
        }
        // Odd
        return ordered[Math.floor(count / 2)];
    };
    /**
     * Static version of the standard deviation function for use with summarize and pivot functions.
     *
     * @param series Input series to find the standard deviation of.
     *
     * @returns Returns the standard deviation of the values in the series.
     *
     * @example
     * <pre>
     *
     * const summary = dataFrame.summarize({
     *      InputColumn: Series.std,
     * });
     * </pre>
     */
    Series.std = function (series) {
        return series.std();
    };
    /**
     * Get the standard deviation of number values in the series.
     *
     * @returns Returns the standard deviation of the values in the series.
     *
     * @example
     * <pre>
     *
     * const salesStdDev = salesFigures.std();
     * </pre>
     */
    Series.prototype.std = function () {
        // Have to assume we are working with a number series here.
        // Bake so we don't evaluate multiple times.
        // TODO: Caching can help here.
        var numberSeries = this.bake();
        var valueCount = numberSeries.count();
        if (valueCount === 0) {
            return 0;
        }
        // https://en.wikipedia.org/wiki/Standard_deviation
        var mean = numberSeries.average();
        var sumOfSquaredDiffs = numberSeries
            .select(function (value) {
            var diffFromMean = value - mean;
            return diffFromMean * diffFromMean;
        })
            .sum();
        return Math.sqrt(sumOfSquaredDiffs / valueCount);
    };
    /**
     * Static version of the min function for use with summarize and pivot functions.
     *
     * @param series Input series to find the minimum of.
     *
     * @returns Returns the minimum of number values in the series.
     *
     * @example
     * <pre>
     *
     * const summary = dataFrame.summarize({
     *      Column: Series.min,
     * });
     * </pre>
     */
    Series.min = function (series) {
        return series.min();
    };
    /**
     * Get the min value in the series.
     *
     * @returns Returns the minimum of the number values in the series.
     *
     * @example
     * <pre>
     *
     * const minSales = salesFigures.min();
     * </pre>
     */
    Series.prototype.min = function () {
        var numberSeries = this; // Have to assume we are working with a number series here.
        return numberSeries.aggregate(function (prev, value) { return Math.min(prev, value); });
    };
    /**
     * Static version of the max function for use with summarize and pivot functions.
     *
     * @param series Input series to find the maximum of.
     *
     * @returns Returns the maximum of number values in the series.
     *
     * @example
     * <pre>
     *
     * const summary = dataFrame.summarize({
     *      Column: Series.max,
     * });
     * </pre>
     */
    Series.max = function (series) {
        return series.max();
    };
    /**
     * Get the max value in the series.
     *
     * @returns Returns the maximum of the number values in the series.
     *
     * @example
     * <pre>
     *
     * const maxSales = salesFigures.max();
     * </pre>
     */
    Series.prototype.max = function () {
        var numberSeries = this; // Have to assume we are working with a number series here.
        return numberSeries.aggregate(function (prev, value) { return Math.max(prev, value); });
    };
    /**
     * Invert the sign of every number value in the series.
     * This assumes that the input series contains numbers.
     *
     * @returns Returns a new series with all number values inverted.
     *
     * @example
     * <pre>
     *
     * const inverted = series.invert();
     * </pre>
     */
    Series.prototype.invert = function () {
        var inputSeries = this;
        return inputSeries.select(function (value) { return -value; });
    };
    /**
     * Counts the number of sequential values where the predicate evaluates to truthy.
     * Outputs 0 for values when the predicate evaluates to falsy.
     *
     * @param predicate User-defined function. Should evaluate to truthy to activate the counter or falsy to deactivate it.
     *
     * @returns Returns a new series that counts up the number of sequential values where the predicate evaluates to truthy. 0 values appear when the prediate evaluates to falsy.
     *
     * @example
     * <pre>
     *
     * const series = new Series([ 1, 10, 3, 15, 8, 5 ]);
     * const counted = series.counter(value => value >= 3);
     * console.log(counted.toString());
     * </pre>
     */
    Series.prototype.counter = function (predicate) {
        return this.groupSequentialBy(predicate)
            .selectMany(function (group, i) {
            if (predicate(group.first())) {
                // This group matches the predicate.
                return __1.range(1, group.count())
                    .withIndex(group.getIndex())
                    .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!
            }
            else {
                // This group doesn't match the predicate.
                return __1.replicate(0, group.count())
                    .withIndex(group.getIndex())
                    .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!
            }
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Gets a new series in reverse order.
     *
     * @return Returns a new series that is the reverse of the original.
     *
     * @example
     * <pre>
     *
     * const reversed = series.reverse();
     * </pre>
     */
    Series.prototype.reverse = function () {
        var _this = this;
        return new Series(function () { return ({
            values: new reverse_iterable_1.ReverseIterable(_this.getContent().values),
            index: new reverse_iterable_1.ReverseIterable(_this.getContent().index),
            pairs: new reverse_iterable_1.ReverseIterable(_this.getContent().pairs)
        }); });
    };
    /**
     * Returns only the set of values in the series that are distinct.
     * Provide a user-defined selector to specify criteria for determining the distinctness.
     * This can be used to remove duplicate values from the series.
     *
     * @param [selector] Optional user-defined selector function that specifies the criteria used to make comparisons for duplicate values.
     *
     * @return Returns a series containing only unique values in the series.
     *
     * @example
     * <pre>
     *
     * const uniqueValues = series.distinct(); // Get only non-duplicated value in the series.
     * </pre>
     *
     * @example
     * <pre>
     *
     * const bucketedValues = series.distinct(value => Math.floor(value / 10)); // Lump values into buckets of 10.
     * </pre>
     */
    Series.prototype.distinct = function (selector) {
        var _this = this;
        return new Series(function () { return ({
            values: new distinct_iterable_1.DistinctIterable(_this.getContent().values, selector),
            pairs: new distinct_iterable_1.DistinctIterable(_this.getContent().pairs, function (pair) { return selector && selector(pair[1]) || pair[1]; })
        }); });
    };
    /**
     * Collects values in the series into a new series of groups according to a user-defined selector function.
     *
     * @param selector User-defined selector function that specifies the criteriay to group by.
     *
     * @return Returns a new series of groups. Each group is a series with values that have been grouped by the 'selector' function.
     *
     * @example
     * <pre>
     *
     * const sales = ... product sales ...
     * const salesByProduct = sales.groupBy(sale => sale.ProductId);
     * for (const productSalesGroup of salesByProduct) {
     *      // ... do something with each product group ...
     *      const productId = productSalesGroup.first().ProductId;
     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();
     *      console.log(totalSalesForProduct);
     * }
     * </pre>
     */
    Series.prototype.groupBy = function (selector) {
        var _this = this;
        if (!utils_1.isFunction(selector))
            throw new Error("Expected 'selector' parameter to 'Series.groupBy' to be a selector function that determines the value to group the series by.");
        return new Series(function () {
            var groups = []; // Each group, in order of discovery.
            var groupMap = {}; // Group map, records groups by key.
            var valueIndex = 0;
            try {
                for (var _a = __values(_this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var pair = _b.value;
                    var groupKey = selector(pair[1], valueIndex);
                    ++valueIndex;
                    var existingGroup = groupMap[groupKey];
                    if (existingGroup) {
                        existingGroup.push(pair);
                    }
                    else {
                        var newGroup = [];
                        newGroup.push(pair);
                        groups.push(newGroup);
                        groupMap[groupKey] = newGroup;
                    }
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_15) throw e_15.error; }
            }
            return {
                values: groups.map(function (group) { return new Series({ pairs: group }); })
            };
            var e_15, _c;
        });
    };
    /**
     * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.
     *
     * @param [selector] Optional selector that specifies the criteria for grouping.
     *
     * @return Returns a new series of groups. Each group is a series with values that are the same or have been grouped by the 'selector' function.
     *
     * @example
     * <pre>
     *
     * // Some ultra simple stock trading strategy backtesting...
     * const dailyStockPrice = ... daily stock price for a company ...
     * const priceGroups  = dailyStockPrice.groupBy(day => day.close > day.movingAverage);
     * for (const priceGroup of priceGroups) {
     *      // ... do something with each stock price group ...
     *
     *      const firstDay = priceGroup.first();
     *      if (firstDay.close > movingAverage) {
     *          // This group of days has the stock price above its moving average.
     *          // ... maybe enter a long trade here ...
     *      }
     *      else {
     *          // This group of days has the stock price below its moving average.
     *          // ... maybe enter a short trade here ...
     *      }
     * }
     * </pre>
     */
    Series.prototype.groupSequentialBy = function (selector) {
        if (selector) {
            if (!utils_1.isFunction(selector))
                throw new Error("Expected 'selector' parameter to 'Series.groupSequentialBy' to be a selector function that determines the value to group the series by.");
        }
        else {
            selector = function (value) { return value; };
        }
        return this.variableWindow(function (a, b) { return selector(a) === selector(b); });
    };
    /**
     * Concatenate multiple series into a single series.
     *
     * @param series - Array of series to concatenate.
     *
     * @returns Returns a single series concatenated from multiple input series.
     */
    Series.concat = function (series) {
        if (!utils_1.isArray(series))
            throw new Error("Expected 'series' parameter to 'Series.concat' to be an array of series.");
        return new Series(function () {
            var upcast = series; // Upcast so that we can access private index, values and pairs.
            var contents = upcast.map(function (series) { return series.getContent(); });
            return {
                values: new concat_iterable_1.ConcatIterable(contents.map(function (content) { return content.values; })),
                pairs: new concat_iterable_1.ConcatIterable(contents.map(function (content) { return content.pairs; })),
            };
        });
    };
    /**
     * Concatenate multiple other series onto this series.
     *
     * @param series Multiple arguments. Each can be either a series or an array of series.
     *
     * @return Returns a single series concatenated from multiple input series.
     *
     * @example
     * <pre>
     *
     * const concatenated = a.concat(b);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const concatenated = a.concat(b, c);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const concatenated = a.concat([b, c]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const concatenated = a.concat(b, [c, d]);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const otherSeries = [... array of series...];
     * const concatenated = a.concat(otherSeries);
     * </pre>
     */
    Series.prototype.concat = function () {
        var series = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            series[_i] = arguments[_i];
        }
        var concatInput = [this];
        try {
            for (var series_2 = __values(series), series_2_1 = series_2.next(); !series_2_1.done; series_2_1 = series_2.next()) {
                var input = series_2_1.value;
                if (utils_1.isArray(input)) {
                    try {
                        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                            var subInput = input_1_1.value;
                            concatInput.push(subInput);
                        }
                    }
                    catch (e_16_1) { e_16 = { error: e_16_1 }; }
                    finally {
                        try {
                            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
                        }
                        finally { if (e_16) throw e_16.error; }
                    }
                }
                else {
                    concatInput.push(input);
                }
            }
        }
        catch (e_17_1) { e_17 = { error: e_17_1 }; }
        finally {
            try {
                if (series_2_1 && !series_2_1.done && (_b = series_2.return)) _b.call(series_2);
            }
            finally { if (e_17) throw e_17.error; }
        }
        return Series.concat(concatInput);
        var e_17, _b, e_16, _a;
    };
    /**
    * Zip together multiple series to create a new series.
    * Preserves the index of the first series.
    *
    * @param series - An iterable of series to be zipped.
    * @param zipper - Selector function that produces a new series based on the input series.
    *
    * @returns Returns a single series zipped from multiple input series.
    */
    Series.zip = function (series, zipper) {
        var input = Array.from(series);
        if (input.length === 0) {
            return new Series();
        }
        var firstSeries = input[0];
        if (firstSeries.none()) {
            return new Series();
        }
        return new Series(function () {
            var firstSeriesUpCast = firstSeries;
            var upcast = input; // Upcast so that we can access private index, values and pairs.
            return {
                index: firstSeriesUpCast.getContent().index,
                values: new zip_iterable_1.ZipIterable(upcast.map(function (s) { return s.getContent().values; }), zipper),
            };
        });
    };
    Series.prototype.zip = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var selector = args[args.length - 1];
        var input = [this].concat(args.slice(0, args.length - 1));
        return Series.zip(input, function (values) { return selector.apply(void 0, __spread(values)); });
    };
    /**
     * Sorts the series in ascending order by a value defined by the user-defined selector function.
     *
     * @param selector User-defined selector function that selects the value to sort by.
     *
     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function.
     *
     * @example
     * <pre>
     *
     * const orderedSeries = series.orderBy(value => value);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const orderedSeries = series.orderBy(value => value.NestedValue);
     * </pre>
     */
    Series.prototype.orderBy = function (selector) {
        var content = this.getContent();
        return new OrderedSeries({
            values: content.values,
            pairs: content.pairs,
            selector: selector,
            direction: ordered_iterable_1.Direction.Ascending,
            parent: null,
        });
    };
    /**
     * Sorts the series in descending order by a value defined by the user-defined selector function.
     *
     * @param selector User-defined selector function that selects the value to sort by.
     *
     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function.
     *
     * @example
     * <pre>
     *
     * const orderedSeries = series.orderByDescending(value => value);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const orderedSeries = series.orderByDescending(value => value.NestedValue);
     * </pre>
     */
    Series.prototype.orderByDescending = function (selector) {
        var content = this.getContent();
        return new OrderedSeries({
            values: content.values,
            pairs: content.pairs,
            selector: selector,
            direction: ordered_iterable_1.Direction.Descending,
            parent: null,
        });
    };
    /**
     * Creates a new series by merging two input dataframes.
     * The resulting series contains the union of value from the two input series.
     * These are the unique combination of values in both series.
     * This is basically a concatenation and then elimination of duplicates.
     *
     * @param other The other series to merge.
     * @param [selector] Optional user-defined selector function that selects the value to compare to determine distinctness.
     *
     * @return Returns the union of the two series.
     *
     * @example
     * <pre>
     *
     * const seriesA = ...
     * const seriesB = ...
     * const merged = seriesA.union(seriesB);
     * </pre>
     *
     * @example
     * <pre>
     *
     * // Merge two sets of customer records that may contain the same
     * // customer record in each set. This is basically a concatenation
     * // of the series and then an elimination of any duplicate records
     * // that result.
     * const customerRecordsA = ...
     * const customerRecordsB = ...
     * const mergedCustomerRecords = customerRecordsA.union(
     *      customerRecordsB,
     *      customerRecord => customerRecord.CustomerId
     * );
     * </pre>
     *
     *
     * @example
     * <pre>
     *
     * // Note that you can achieve the exact same result as the previous
     * // example by doing a {@link Series.concat) and {@link Series.distinct}
     * // of the input series and then an elimination of any duplicate records
     * // that result.
     * const customerRecordsA = ...
     * const customerRecordsB = ...
     * const mergedCustomerRecords = customerRecordsA
     *      .concat(customerRecordsB)
     *      .distinct(customerRecord => customerRecord.CustomerId);
     * </pre>
     *
     */
    Series.prototype.union = function (other, selector) {
        if (selector) {
            if (!utils_1.isFunction(selector))
                throw new Error("Expected optional 'selector' parameter to 'Series.union' to be a selector function.");
        }
        return this.concat(other).distinct(selector);
    };
    ;
    /**
     * Creates a new series by merging two input series.
     * The resulting series contains the intersection of values from the two input series.
     * These are only the values that appear in both series.
     *
     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).
     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer series that is used to match the two series.
     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner series that is used to match the two series.
     *
     * @return Returns a new series that contains the intersection of values from the two input series.
     *
     * @example
     * <pre>
     *
     * const seriesA = ...
     * const seriesB = ...
     * const mergedDf = seriesA.intersection(seriesB);
     * </pre>
     *
     * @example
     * <pre>
     *
     * // Merge two sets of customer records to find only the
     * // customers that appears in both.
     * const customerRecordsA = ...
     * const customerRecordsB = ...
     * const intersectionOfCustomerRecords = customerRecordsA.intersection(
     *      customerRecordsB,
     *      customerRecord => customerRecord.CustomerId
     * );
     * </pre>
     */
    Series.prototype.intersection = function (inner, outerSelector, innerSelector) {
        if (outerSelector) {
            if (!utils_1.isFunction(outerSelector))
                throw new Error("Expected optional 'outerSelector' parameter to 'Series.intersection' to be a function.");
        }
        else {
            outerSelector = function (value) { return value; };
        }
        if (innerSelector) {
            if (!utils_1.isFunction(innerSelector))
                throw new Error("Expected optional 'innerSelector' parameter to 'Series.intersection' to be a function.");
        }
        else {
            innerSelector = function (value) { return value; };
        }
        var outer = this;
        return outer.where(function (outerValue) {
            var outerKey = outerSelector(outerValue);
            return inner
                .where(function (innerValue) { return outerKey === innerSelector(innerValue); })
                .any();
        });
    };
    ;
    /**
     * Creates a new series by merging two input series.
     * The resulting series contains only the values from the 1st series that don't appear in the 2nd series.
     * This is essentially subtracting the values from the 2nd series from the 1st and creating a new series with the remaining values.
     *
     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).
     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer series that is used to match the two series.
     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner series that is used to match the two series.
     *
     * @return Returns a new series that contains only the values from the 1st series that don't appear in the 2nd series.
     *
     * @example
     * <pre>
     *
     * const seriesA = ...
     * const seriesB = ...
     * const remainingDf = seriesA.except(seriesB);
     * </pre>
     *
     * @example
     * <pre>
     *
     * // Find the list of customers haven't bought anything recently.
     * const allCustomers = ... list of all customers ...
     * const recentCustomers = ... list of customers who have purchased recently ...
     * const remainingCustomers = allCustomers.except(
     *      recentCustomers,
     *      customerRecord => customerRecord.CustomerId
     * );
     * </pre>
     */
    Series.prototype.except = function (inner, outerSelector, innerSelector) {
        if (outerSelector) {
            if (!utils_1.isFunction(outerSelector))
                throw new Error("Expected optional 'outerSelector' parameter to 'Series.except' to be a function.");
        }
        else {
            outerSelector = function (value) { return value; };
        }
        if (innerSelector) {
            if (!utils_1.isFunction(innerSelector))
                throw new Error("Expected optional 'innerSelector' parameter to 'Series.except' to be a function.");
        }
        else {
            innerSelector = function (value) { return value; };
        }
        var outer = this;
        return outer.where(function (outerValue) {
            var outerKey = outerSelector(outerValue);
            return inner
                .where(function (innerValue) { return outerKey === innerSelector(innerValue); })
                .none();
        });
    };
    ;
    /**
      * Creates a new series by merging two input series.
      * The resulting dataframe contains only those value that have matching keys in both input series.
      *
      * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).
      * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.
      * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.
      * @param resultSelector User-defined function that merges outer and inner values.
      *
      * @return Returns the new merged series.
      *
      * @example
      * <pre>
      *
      * // Join together two sets of customers to find those
      * // that have bought both product A and product B.
      * const customerWhoBoughtProductA = ...
      * const customerWhoBoughtProductB = ...
      * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(
      *          customerWhoBoughtProductB,
      *          customerA => customerA.CustomerId, // Join key.
      *          customerB => customerB.CustomerId, // Join key.
      *          (customerA, customerB) => {
      *              return {
      *                  // ... merge the results ...
      *              };
      *          }
      *      );
      * </pre>
      */
    Series.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        if (!utils_1.isFunction(outerKeySelector))
            throw new Error("Expected 'outerKeySelector' parameter of 'Series.join' to be a selector function.");
        if (!utils_1.isFunction(innerKeySelector))
            throw new Error("Expected 'innerKeySelector' parameter of 'Series.join' to be a selector function.");
        if (!utils_1.isFunction(resultSelector))
            throw new Error("Expected 'resultSelector' parameter of 'Series.join' to be a selector function.");
        var outer = this;
        return new Series(function () {
            var innerMap = inner
                .groupBy(innerKeySelector)
                .toObject(function (group) { return innerKeySelector(group.first()); }, function (group) { return group; });
            var outerContent = outer.getContent();
            var output = [];
            try {
                for (var outer_1 = __values(outer), outer_1_1 = outer_1.next(); !outer_1_1.done; outer_1_1 = outer_1.next()) {
                    var outerValue = outer_1_1.value;
                    var outerKey = outerKeySelector(outerValue);
                    var innerGroup = innerMap[outerKey];
                    if (innerGroup) {
                        try {
                            for (var innerGroup_1 = __values(innerGroup), innerGroup_1_1 = innerGroup_1.next(); !innerGroup_1_1.done; innerGroup_1_1 = innerGroup_1.next()) {
                                var innerValue = innerGroup_1_1.value;
                                output.push(resultSelector(outerValue, innerValue));
                            }
                        }
                        catch (e_18_1) { e_18 = { error: e_18_1 }; }
                        finally {
                            try {
                                if (innerGroup_1_1 && !innerGroup_1_1.done && (_a = innerGroup_1.return)) _a.call(innerGroup_1);
                            }
                            finally { if (e_18) throw e_18.error; }
                        }
                    }
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (outer_1_1 && !outer_1_1.done && (_b = outer_1.return)) _b.call(outer_1);
                }
                finally { if (e_19) throw e_19.error; }
            }
            return {
                values: output
            };
            var e_19, _b, e_18, _a;
        });
    };
    /**
     * Creates a new series by merging two input series.
     * The resulting series contains only those values that are only present in or or the other of the series, not both.
     *
     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).
     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.
     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.
     * @param resultSelector User-defined function that merges outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @return Returns the new merged series.
     *
     * @example
     * <pre>
     *
     * // Join together two sets of customers to find those
     * // that have bought either product A or product B, not not both.
     * const customerWhoBoughtProductA = ...
     * const customerWhoBoughtProductB = ...
     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(
     *          customerWhoBoughtProductB,
     *          customerA => customerA.CustomerId, // Join key.
     *          customerB => customerB.CustomerId, // Join key.
     *          (customerA, customerB) => {
     *              return {
     *                  // ... merge the results ...
     *              };
     *          }
     *      );
     * </pre>
     */
    Series.prototype.joinOuter = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        if (!utils_1.isFunction(outerKeySelector))
            throw new Error("Expected 'outerKeySelector' parameter of 'Series.joinOuter' to be a selector function.");
        if (!utils_1.isFunction(innerKeySelector))
            throw new Error("Expected 'innerKeySelector' parameter of 'Series.joinOuter' to be a selector function.");
        if (!utils_1.isFunction(resultSelector))
            throw new Error("Expected 'resultSelector' parameter of 'Series.joinOuter' to be a selector function.");
        // Get the results in the outer that are not in the inner.
        var outer = this;
        var outerResult = outer.except(inner, outerKeySelector, innerKeySelector)
            .select(function (outer) { return resultSelector(outer, null); })
            .resetIndex();
        // Get the results in the inner that are not in the outer.
        var innerResult = inner.except(outer, innerKeySelector, outerKeySelector)
            .select(function (inner) { return resultSelector(null, inner); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return outerResult
            .concat(intersectionResults)
            .concat(innerResult)
            .resetIndex();
    };
    ;
    /**
     * Creates a new series by merging two input series.
     * The resulting series contains only those values that are present either in both series or only in the outer (left) series.
     *
     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).
     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.
     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.
     * @param resultSelector User-defined function that merges outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @return Returns the new merged series.
     *
     * @example
     * <pre>
     *
     * // Join together two sets of customers to find those
     * // that have bought either just product A or both product A and product B.
     * const customerWhoBoughtProductA = ...
     * const customerWhoBoughtProductB = ...
     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(
     *          customerWhoBoughtProductB,
     *          customerA => customerA.CustomerId, // Join key.
     *          customerB => customerB.CustomerId, // Join key.
     *          (customerA, customerB) => {
     *              return {
     *                  // ... merge the results ...
     *              };
     *          }
     *      );
     * </pre>
     */
    Series.prototype.joinOuterLeft = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        if (!utils_1.isFunction(outerKeySelector))
            throw new Error("Expected 'outerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.");
        if (!utils_1.isFunction(innerKeySelector))
            throw new Error("Expected 'innerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.");
        if (!utils_1.isFunction(resultSelector))
            throw new Error("Expected 'resultSelector' parameter of 'Series.joinOuterLeft' to be a selector function.");
        // Get the results in the outer that are not in the inner.
        var outer = this;
        var outerResult = outer.except(inner, outerKeySelector, innerKeySelector)
            .select(function (outer) { return resultSelector(outer, null); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return outerResult
            .concat(intersectionResults)
            .resetIndex();
    };
    ;
    /**
     * Creates a new series by merging two input series.
     * The resulting series contains only those values that are present either in both series or only in the inner (right) series.
     *
     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).
     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.
     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.
     * @param resultSelector User-defined function that merges outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @return Returns the new merged series.
     *
     * @example
     * <pre>
     *
     * // Join together two sets of customers to find those
     * // that have bought either just product B or both product A and product B.
     * const customerWhoBoughtProductA = ...
     * const customerWhoBoughtProductB = ...
     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(
     *          customerWhoBoughtProductB,
     *          customerA => customerA.CustomerId, // Join key.
     *          customerB => customerB.CustomerId, // Join key.
     *          (customerA, customerB) => {
     *              return {
     *                  // ... merge the results ...
     *              };
     *          }
     *      );
     * </pre>
     */
    Series.prototype.joinOuterRight = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        if (!utils_1.isFunction(outerKeySelector))
            throw new Error("Expected 'outerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.");
        if (!utils_1.isFunction(innerKeySelector))
            throw new Error("Expected 'innerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.");
        if (!utils_1.isFunction(resultSelector))
            throw new Error("Expected 'resultSelector' parameter of 'Series.joinOuterRight' to be a selector function.");
        // Get the results in the inner that are not in the outer.
        var outer = this;
        var innerResult = inner.except(outer, innerKeySelector, outerKeySelector)
            .select(function (inner) { return resultSelector(null, inner); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return intersectionResults
            .concat(innerResult)
            .resetIndex();
    };
    /**
     * Produces a new series with all string values truncated to the requested maximum length.
     *
     * @param maxLength - The maximum length of the string values after truncation.
     *
     * @returns Returns a new series with strings that are truncated to the specified maximum length.
     *
     * @example
     * <pre>
     *
     * const truncated = series.truncateStrings(10); // Truncate all string values to max length of 10 characters.
     * </pre>
     */
    Series.prototype.truncateStrings = function (maxLength) {
        if (!utils_1.isNumber(maxLength))
            throw new Error("Expected 'maxLength' parameter to 'Series.truncateStrings' to be a number.");
        return this.select(function (value) {
            if (utils_1.isString(value)) {
                if (value.length > maxLength) {
                    return value.substring(0, maxLength);
                }
            }
            return value;
        });
    };
    ;
    /**
     * Insert a pair at the start of the series.
     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the inserted pair.
     *
     * @param pair The index/value pair to insert.
     *
     * @return Returns a new series with the specified pair inserted.
     *
     * @example
     * <pre>
     *
     * const newIndex = ... index of the new row ...
     * const newRow = ... the new data row to insert ...
     * const insertedSeries = series.insertPair([newIndex, newRows]);
     * </pre>
     */
    Series.prototype.insertPair = function (pair) {
        if (!utils_1.isArray(pair))
            throw new Error("Expected 'pair' parameter to 'Series.insertPair' to be an array.");
        if (pair.length !== 2)
            throw new Error("Expected 'pair' parameter to 'Series.insertPair' to be an array with two elements. The first element is the index, the second is the value.");
        return (new Series({ pairs: [pair] })).concat(this);
    };
    /**
     * Append a pair to the end of a series.
     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the appended pair.
     *
     * @param pair The index/value pair to append.
     *
     * @return Returns a new series with the specified pair appended.
     *
     * @example
     * <pre>
     *
     * const newIndex = ... index of the new row ...
     * const newRow = ... the new data row to append ...
     * const appendedSeries = series.appendPair([newIndex, newRows]);
     * </pre>
     */
    Series.prototype.appendPair = function (pair) {
        if (!utils_1.isArray(pair))
            throw new Error("Expected 'pair' parameter to 'Series.appendPair' to be an array.");
        if (pair.length !== 2)
            throw new Error("Expected 'pair' parameter to 'Series.appendPair' to be an array with two elements. The first element is the index, the second is the value.");
        return this.concat(new Series({ pairs: [pair] }));
    };
    /**
     * Fill gaps in a series.
     *
     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive values, return truthy if there is a gap between the value, or falsey if there is no gap.
     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive values, returns an array of pairs that fills the gap between the values.
     *
     * @return Returns a new series with gaps filled in.
     *
     * @example
     * <pre>
     *
     *   var sequenceWithGaps = ...
     *
     *  // Predicate that determines if there is a gap.
     *  var gapExists = (pairA, pairB) => {
     *      // Returns true if there is a gap.
     *      return true;
     *  };
     *
     *  // Generator function that produces new rows to fill the game.
     *  var gapFiller = (pairA, pairB) => {
     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.
     *      return [
     *          newPair1,
     *          newPair2,
     *          newPair3,
     *      ];
     *  };
     *
     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);
     * </pre>
     */
    Series.prototype.fillGaps = function (comparer, generator) {
        if (!utils_1.isFunction(comparer))
            throw new Error("Expected 'comparer' parameter to 'Series.fillGaps' to be a comparer function that compares two values and returns a boolean.");
        if (!utils_1.isFunction(generator))
            throw new Error("Expected 'generator' parameter to 'Series.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.");
        return this.rollingWindow(2)
            .selectMany(function (window) {
            var pairs = window.toPairs();
            var pairA = pairs[0];
            var pairB = pairs[1];
            if (!comparer(pairA, pairB)) {
                return [pairA];
            }
            var generatedRows = generator(pairA, pairB);
            if (!utils_1.isArray(generatedRows))
                throw new Error("Expected return from 'generator' parameter to 'Series.fillGaps' to be an array of pairs, instead got a " + typeof (generatedRows));
            return [pairA].concat(generatedRows);
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; })
            .concat(this.tail(1));
    };
    /**
     * Returns the specified default series if the input series is empty.
     *
     * @param defaultSequence Default series to return if the input series is empty.
     *
     * @return Returns 'defaultSequence' if the input series is empty.
     *
     * @example
     * <pre>
     *
     * const emptySeries = new Series();
     * const defaultSeries = new Series([ 1, 2, 3 ]);
     * expect(emptyDataFrame.defaultIfEmpty(defaultSeries)).to.eql(defaultSeries);
     * </pre>
     *
     * @example
     * <pre>
     *
     * const nonEmptySeries = new Series([ 100 ]);
     * const defaultSeries = new Series([ 1, 2, 3 ]);
     * expect(nonEmptySeries.defaultIfEmpty(defaultSeries)).to.eql(nonEmptySeries);
     * </pre>
     */
    Series.prototype.defaultIfEmpty = function (defaultSequence) {
        if (this.none()) {
            if (defaultSequence instanceof Series) {
                return defaultSequence;
            }
            else if (utils_1.isArray(defaultSequence)) {
                return new Series(defaultSequence);
            }
            else {
                throw new Error("Expected 'defaultSequence' parameter to 'Series.defaultIfEmpty' to be an array or a series.");
            }
        }
        else {
            return this;
        }
    };
    /**
     * Detect the the frequency of the types of the values in the series.
     * This is a good way to understand the shape of your data.
     *
     * @return Returns a {@link DataFrame} with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original series.
     *
     * @example
     * <pre>
     *
     * const dataTypes = series.detectTypes();
     * console.log(dataTypes.toString());
     * </pre>
     */
    Series.prototype.detectTypes = function () {
        var _this = this;
        return new dataframe_1.DataFrame(function () {
            var totalValues = _this.count();
            var typeFrequencies = _this.select(function (value) {
                var valueType = typeof (value);
                if (valueType === "object") {
                    if (utils_1.isDate(value)) {
                        valueType = "date";
                    }
                }
                return valueType;
            })
                .aggregate({}, function (accumulated, valueType) {
                var typeInfo = accumulated[valueType];
                if (!typeInfo) {
                    typeInfo = {
                        count: 0
                    };
                    accumulated[valueType] = typeInfo;
                }
                ++typeInfo.count;
                return accumulated;
            });
            return {
                columnNames: ["Type", "Frequency"],
                rows: Object.keys(typeFrequencies)
                    .map(function (valueType) {
                    return [
                        valueType,
                        (typeFrequencies[valueType].count / totalValues) * 100
                    ];
                })
            };
        });
    };
    /**
     * Detect the frequency of the values in the series.
     * This is a good way to understand the shape of your data.
     *
     * @return Returns a {@link DataFrame} with rows that conform to {@link IValueFrequency} that describes the values contained in the original series.
     *
     * @example
     * <pre>
     *
     * const dataValues = series.detectValues();
     * console.log(dataValues.toString());
     * </pre>
     */
    Series.prototype.detectValues = function () {
        var _this = this;
        return new dataframe_1.DataFrame(function () {
            var totalValues = _this.count();
            var valueFrequencies = _this.aggregate(new Map(), function (accumulated, value) {
                var valueInfo = accumulated.get(value);
                if (!valueInfo) {
                    valueInfo = {
                        count: 0,
                        value: value,
                    };
                    accumulated.set(value, valueInfo);
                }
                ++valueInfo.count;
                return accumulated;
            });
            return {
                columnNames: ["Value", "Frequency"],
                rows: Array.from(valueFrequencies.keys())
                    .map(function (value) {
                    var valueInfo = valueFrequencies.get(value);
                    return [
                        valueInfo.value,
                        (valueInfo.count / totalValues) * 100
                    ];
                }),
            };
        });
    };
    /**
     * Organise all values in the series into the specified number of buckets.
     * Assumes that the series is a series of numbers.
     *
     * @param numBuckets - The number of buckets to create.
     *
     * @returns Returns a dataframe containing bucketed values. The input values are divided up into these buckets.
     *
     * @example
     * <pre>
     *
     * const buckets = series.bucket(20); // Distribute values into 20 evenly spaced buckets.
     * console.log(buckets.toString());
     * </pre>
     */
    Series.prototype.bucket = function (numBuckets) {
        if (!utils_1.isNumber(numBuckets)) {
            throw new Error("Expected 'numBuckets' parameter to 'Series.bucket' to be a number.");
        }
        if (this.none()) {
            return new dataframe_1.DataFrame();
        }
        var numberSeries = this;
        var min = numberSeries.min();
        var max = numberSeries.max();
        var range = max - min;
        var width = range / (numBuckets - 1);
        return numberSeries.select(function (v) {
            var bucket = Math.floor((v - min) / width);
            var bucketMin = (bucket * width) + min;
            return {
                Value: v,
                Bucket: bucket,
                Min: bucketMin,
                Mid: bucketMin + (width * 0.5),
                Max: bucketMin + width,
            };
        })
            .inflate();
    };
    /***
     * Allows the series to be queried to confirm that it is actually a series.
     * Used from JavaScript to tell the difference between a Series and a DataFrame.
     *
     * @return Returns the string "series".
     */
    Series.prototype.getTypeCode = function () {
        return "series";
    };
    Series.defaultCountIterable = new count_iterable_1.CountIterable();
    Series.defaultEmptyIterable = new empty_iterable_1.EmptyIterable();
    return Series;
}());
exports.Series = Series;
/**
 * @hidden
 * A series that has been ordered.
 */
var OrderedSeries = /** @class */ (function (_super) {
    __extends(OrderedSeries, _super);
    function OrderedSeries(config) {
        var _this = this;
        var valueSortSpecs = [];
        var pairSortSpecs = [];
        var sortLevel = 0;
        var parent = config.parent;
        while (parent !== null) {
            var parentConfig = parent.config;
            valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, parentConfig.selector, parentConfig.direction));
            pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(parentConfig.selector), parentConfig.direction));
            ++sortLevel;
            parent = parentConfig.parent;
        }
        valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, config.selector, config.direction));
        pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(config.selector), config.direction));
        _this = _super.call(this, {
            values: new ordered_iterable_1.OrderedIterable(config.values, valueSortSpecs),
            pairs: new ordered_iterable_1.OrderedIterable(config.pairs, pairSortSpecs)
        }) || this;
        _this.config = config;
        return _this;
    }
    //
    // Helper function to create a sort spec.
    //
    OrderedSeries.makeSortSpec = function (sortLevel, selector, direction) {
        return { sortLevel: sortLevel, selector: selector, direction: direction };
    };
    //
    // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.
    //
    OrderedSeries.makePairsSelector = function (selector) {
        return function (pair, index) { return selector(pair[1], index); };
    };
    /**
     * Applys additional sorting (ascending) to an already sorted series.
     *
     * @param selector User-defined selector that selects the additional value to sort by.
     *
     * @return Returns a new series has been additionally sorted by the value chosen by the selector function.
     *
     * @example
     * <pre>
     *
     * // Order sales by salesperson and then by amount (from least to most).
     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);
     * </pre>
     */
    OrderedSeries.prototype.thenBy = function (selector) {
        return new OrderedSeries({
            values: this.config.values,
            pairs: this.config.pairs,
            selector: selector,
            direction: ordered_iterable_1.Direction.Ascending,
            parent: this,
        });
    };
    /**
     * Applys additional sorting (descending) to an already sorted series.
     *
     * @param selector User-defined selector that selects the additional value to sort by.
     *
     * @return Returns a new series has been additionally sorted by the value chosen by the selector function.
     *
     * @example
     * <pre>
     *
     * // Order sales by salesperson and then by amount (from most to least).
     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);
     * </pre>
     */
    OrderedSeries.prototype.thenByDescending = function (selector) {
        return new OrderedSeries({
            values: this.config.values,
            pairs: this.config.pairs,
            selector: selector,
            direction: ordered_iterable_1.Direction.Descending,
            parent: this
        });
    };
    return OrderedSeries;
}(Series));
//# sourceMappingURL=series.js.map