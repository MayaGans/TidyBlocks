"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./lib/index");
exports.Index = index_1.Index;
var series_1 = require("./lib/series");
exports.Series = series_1.Series;
var dataframe_1 = require("./lib/dataframe");
exports.DataFrame = dataframe_1.DataFrame;
var _1 = require(".");
var _2 = require(".");
var utils_1 = require("./lib/utils");
var util_1 = require("util");
// @ts-ignore
var dayjs_1 = __importDefault(require("dayjs"));
// @ts-ignore
var customParseFormat_1 = __importDefault(require("dayjs/plugin/customParseFormat"));
dayjs_1.default.extend(customParseFormat_1.default);
// @ts-ignore
var papaparse_1 = __importDefault(require("papaparse"));
;
/**
 * Convert a regular JavaScript obejct to a dataframe.
 * Each row in the dataframe represents a field from the object.
 *
 * @param obj - The JavaScript object to convert to a dataframe.
 *
 * @returns Returns a dataframe that lists the fields in the pass-in object.
 */
function fromObject(obj) {
    return new _2.DataFrame(Object.keys(obj)
        .map(function (fieldName) { return ({
        Field: fieldName,
        Value: obj[fieldName],
    }); }));
}
exports.fromObject = fromObject;
/**
 * Deserialize a dataframe from a JSON text string.
 *
 * @param jsonTextString The JSON text to deserialize.
 *
 * @returns Returns a dataframe that has been deserialized from the JSON data.
 */
function fromJSON(jsonTextString) {
    if (!utils_1.isString(jsonTextString))
        throw new Error("Expected 'jsonTextString' parameter to 'dataForge.fromJSON' to be a string containing data encoded in the JSON format.");
    return new _2.DataFrame({
        values: JSON.parse(jsonTextString)
    });
}
exports.fromJSON = fromJSON;
/**
 * Deserialize a DataFrame from a CSV text string.
 *
 * @param csvTextString The CSV text to deserialize.
 * @param [config] Optional configuration options for parsing the CSV data.
 *
 * @returns Returns a dataframe that has been deserialized from the CSV data.
 */
function fromCSV(csvTextString, config) {
    if (!utils_1.isString(csvTextString))
        throw new Error("Expected 'csvTextString' parameter to 'dataForge.fromCSV' to be a string containing data encoded in the CSV format.");
    if (config) {
        if (!utils_1.isObject(config))
            throw new Error("Expected 'config' parameter to 'dataForge.fromCSV' to be an object with CSV parsing configuration options.");
        if (config.columnNames) {
            if (!util_1.isFunction(config.columnNames[Symbol.iterator])) {
                if (!utils_1.isArray(config.columnNames))
                    throw new Error("Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array or iterable of strings that specifies column names.");
            }
            try {
                for (var _a = __values(config.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var columnName = _b.value;
                    if (!utils_1.isString(columnName))
                        throw new Error("Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array of strings that specify column names.");
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (config.skipEmptyLines === undefined) {
            config = Object.assign({}, config); // Clone the config. Don't want to modify the original.
            config.skipEmptyLines = true;
        }
    }
    else {
        config = {
            skipEmptyLines: true,
        };
    }
    var parsed = papaparse_1.default.parse(csvTextString, config);
    var rows = parsed.data;
    if (rows.length === 0) {
        return new _2.DataFrame();
    }
    var columnNames;
    rows = rows.map(function (row) {
        return row.map(function (cell) { return utils_1.isString(cell) ? cell.trim() : cell; }); // Trim each cell that is still a string.
    });
    if (config && config.columnNames) {
        columnNames = config.columnNames;
    }
    else {
        columnNames = rows.shift();
    }
    return new _2.DataFrame({
        rows: rows,
        columnNames: columnNames,
    });
    var e_1, _c;
}
exports.fromCSV = fromCSV;
var concat = _1.Series.concat;
exports.concatSeries = concat;
var zip = _1.Series.zip;
exports.zipSeries = zip;
/**
 * Generate a series from a range of numbers.
 *
 * @param start - The value of the first number in the range.
 * @param count - The number of sequential values in the range.
 *
 * @returns Returns a series with a sequence of generated values. The series contains 'count' values beginning at 'start'.
 */
function range(start, count) {
    if (!utils_1.isNumber(start))
        throw new Error("Expect 'start' parameter to 'dataForge.range' function to be a number.");
    if (!utils_1.isNumber(count))
        throw new Error("Expect 'count' parameter to 'dataForge.range' function to be a number.");
    var values = [];
    for (var valueIndex = 0; valueIndex < count; ++valueIndex) {
        values.push(start + valueIndex);
    }
    return new _1.Series(values);
}
exports.range = range;
/**
 * Replicate a particular value N times to create a series.
 *
 * @param value The value to replicate.
 * @param count The number of times to replicate the value.
 *
 * @returns Returns a new series that contains N copies of the value.
 */
function replicate(value, count) {
    var values = [];
    for (var i = 0; i < count; ++i) {
        values.push(value);
    }
    return new _1.Series(values);
}
exports.replicate = replicate;
/**
 * Generate a data-frame containing a matrix of values.
 *
 * @param numColumns - The number of columns in the data-frame.
 * @param numRows - The number of rows in the data-frame.
 * @param start - The starting value.
 * @param increment - The value to increment by for each new value.
 *
 * @returns Returns a dataframe that contains a matrix of generated values.
 */
function matrix(numColumns, numRows, start, increment) {
    if (!utils_1.isNumber(numColumns))
        throw new Error("Expect 'numColumns' parameter to 'dataForge.matrix' function to be a number.");
    if (!utils_1.isNumber(numRows))
        throw new Error("Expect 'numRows' parameter to 'dataForge.matrix' function to be a number.");
    if (!utils_1.isNumber(start))
        throw new Error("Expect 'start' parameter to 'dataForge.matrix' function to be a number.");
    if (!utils_1.isNumber(increment))
        throw new Error("Expect 'increment' parameter to 'dataForge.matrix' function to be a number.");
    var rows = [];
    var columnNames = [];
    var nextValue = start;
    for (var colIndex = 0; colIndex < numColumns; ++colIndex) {
        columnNames.push((colIndex + 1).toString());
    }
    for (var rowIndex = 0; rowIndex < numRows; ++rowIndex) {
        var row = [];
        for (var colIndex = 0; colIndex < numColumns; ++colIndex) {
            row.push(nextValue + (colIndex * increment));
        }
        nextValue += numColumns * increment;
        rows.push(row);
    }
    return new _2.DataFrame({
        columnNames: columnNames,
        rows: rows,
    });
}
exports.matrix = matrix;
//# sourceMappingURL=index.js.map