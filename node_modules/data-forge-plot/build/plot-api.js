"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var opn = require("opn");
var path = require("path");
var inflate_template_1 = require("inflate-template");
var utils_1 = require("./utils");
var expand_chart_def_1 = require("./expand-chart-def");
var apply_defaults_1 = require("./apply-defaults");
var DEFAULT_CHART_PACKAGE = "@data-forge-plot/apex";
//
// Reusable chart renderer.
// For improved performance.
//
// TODO :export let globalChartRenderer: IChartRenderer | null = null;
function findChartTemplatePath() {
    return __awaiter(this, void 0, void 0, function () {
        var defaultTemplatePath, chartTemplatesPath;
        return __generator(this, function (_a) {
            defaultTemplatePath = require.resolve(DEFAULT_CHART_PACKAGE + "/build/template/template.json");
            chartTemplatesPath = path.dirname(defaultTemplatePath);
            return [2 /*return*/, chartTemplatesPath];
        });
    });
}
exports.findChartTemplatePath = findChartTemplatePath;
function startPlot() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/];
        });
    });
}
exports.startPlot = startPlot;
function endPlot() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/];
        });
    });
}
exports.endPlot = endPlot;
/**
 * Fluent API for configuring the plot.
 */
var AbstractPlotAPI = /** @class */ (function () {
    function AbstractPlotAPI(chartDef, plotDefaults) {
        this.chartDef = chartDef;
        this.plotDefaults = plotDefaults;
    }
    /**
     * Set the type of the chart to be plotted.
     *
     * @param chartType Specifies the chart type.
     */
    AbstractPlotAPI.prototype.chartType = function (chartType) {
        this.chartDef.plotConfig.chartType = chartType; // TODO: could call toLower, would have to also toLower the config.
        return this;
    };
    /**
     * Set the width of the chart.
     */
    AbstractPlotAPI.prototype.width = function (width) {
        this.chartDef.plotConfig.width = width;
        return this;
    };
    /**
     * Set the height of the chart.
     */
    AbstractPlotAPI.prototype.height = function (height) {
        this.chartDef.plotConfig.height = height;
        return this;
    };
    /**
     * Configure the default x axis.
     */
    AbstractPlotAPI.prototype.x = function () {
        var _this = this;
        if (!this.chartDef.plotConfig.x) {
            this.chartDef.plotConfig.x = {};
        }
        return new XAxisConfigAPI("x", this.chartDef.plotConfig.x, function (seriesName) {
            if (_this.chartDef.axisMap.x) {
                _this.chartDef.axisMap.x.series = seriesName;
                return _this.chartDef.axisMap.x;
            }
            else {
                var seriesConfig = {
                    series: seriesName,
                };
                _this.chartDef.axisMap.x = seriesConfig;
                return seriesConfig;
            }
        }, this.chartDef);
    };
    /**
     * Configure the y axis.
     */
    AbstractPlotAPI.prototype.y = function () {
        var _this = this;
        if (!this.chartDef.plotConfig.y) {
            this.chartDef.plotConfig.y = {};
        }
        return new YAxisConfigAPI("y", this.chartDef.plotConfig.y, function (seriesName) {
            var seriesConfig = {
                series: seriesName,
            };
            _this.chartDef.axisMap.y.push(seriesConfig);
            return seriesConfig;
        }, this.chartDef);
    };
    /**
     * Configure the y axis.
     */
    AbstractPlotAPI.prototype.y2 = function () {
        var _this = this;
        if (!this.chartDef.plotConfig.y2) {
            this.chartDef.plotConfig.y2 = {};
        }
        return new YAxisConfigAPI("y2", this.chartDef.plotConfig.y2, function (seriesName) {
            var seriesConfig = {
                series: seriesName,
            };
            _this.chartDef.axisMap.y2.push(seriesConfig);
            return seriesConfig;
        }, this.chartDef);
    };
    /**
     * Export an interactive web visualization of the chart.
     */
    AbstractPlotAPI.prototype.exportWeb = function (outputFolderPath, exportOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var chartDef, templatePath, _a, overwrite, exportTemplateOptions;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        chartDef = this.serialize();
                        if (exportOptions && exportOptions.showChartDef) {
                            console.log("Expanded chart definition:");
                            console.log(JSON.stringify(chartDef, null, 4));
                        }
                        _a = exportOptions && exportOptions.template;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, findChartTemplatePath()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        templatePath = _a;
                        overwrite = exportOptions && !!exportOptions.overwrite || false;
                        exportTemplateOptions = {
                            overwrite: overwrite,
                            inMemoryFiles: [
                                {
                                    file: "chart-def.json",
                                    content: JSON.stringify({
                                        chartDef: chartDef,
                                        options: {
                                            makeStatic: false,
                                            showChartDef: exportOptions && exportOptions.showChartDef || false,
                                        },
                                    }, null, 4),
                                },
                            ],
                        };
                        return [4 /*yield*/, inflate_template_1.exportTemplate(templatePath, { chartDef: chartDef }, outputFolderPath, exportTemplateOptions)];
                    case 3:
                        _b.sent();
                        if (exportOptions && exportOptions.openBrowser) {
                            opn("file://" + path.resolve(path.join(outputFolderPath, "index.html")));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Serialize the plot definition so that it can be converted to JSON.
     * The JSON definition of the chart can be used to instantiate the chart in a browser.
     */
    AbstractPlotAPI.prototype.serialize = function () {
        return apply_defaults_1.applyDefaults(this.chartDef, this.plotDefaults); // Set missing default values after configuration by the fluent.
    };
    /**
     * Used to external detect the type of this object.
     */
    AbstractPlotAPI.prototype.getTypeCode = function () {
        return "plot";
    };
    return AbstractPlotAPI;
}());
exports.AbstractPlotAPI = AbstractPlotAPI;
/**
 * Fluent API for configuring the plot.
 */
var PlotAPI = /** @class */ (function (_super) {
    __extends(PlotAPI, _super);
    function PlotAPI(data, plotConfig, axisMap, plotDefaults) {
        var _this = this;
        if (!utils_1.isObject(data)) {
            throw new Error("Expected 'data' parameter to PlotAPI constructor to be a serialized dataframe.");
        }
        _this = _super.call(this, expand_chart_def_1.expandChartDef(data, plotConfig, axisMap), plotDefaults) || this;
        return _this;
    }
    /**
     * Deserialize an instance of PlotAPI from a previously serialize chart def.
     *
     * @param chartDef The chart definition to deserialize from.
     */
    PlotAPI.deserialize = function (chartDef) {
        return new PlotAPI(chartDef.data, chartDef.plotConfig, chartDef.axisMap);
    };
    return PlotAPI;
}(AbstractPlotAPI));
exports.PlotAPI = PlotAPI;
/**
 * Fluent API for series configuration.
 */
var AxisSeriesConfigAPI = /** @class */ (function (_super) {
    __extends(AxisSeriesConfigAPI, _super);
    function AxisSeriesConfigAPI(seriesName, seriesConfig, chartDef) {
        var _this = _super.call(this, chartDef) || this;
        _this.seriesName = seriesName;
        _this.seriesConfig = seriesConfig;
        return _this;
    }
    return AxisSeriesConfigAPI;
}(AbstractPlotAPI));
/**
 * Fluent API for X axis series configuration.
 */
var XAxisSeriesConfigAPI = /** @class */ (function (_super) {
    __extends(XAxisSeriesConfigAPI, _super);
    function XAxisSeriesConfigAPI(seriesName, seriesConfig, chartDef) {
        return _super.call(this, seriesName, seriesConfig, chartDef) || this;
    }
    return XAxisSeriesConfigAPI;
}(AxisSeriesConfigAPI));
/**
 * Fluent API for Y axis series configuration.
 */
var YAxisSeriesConfigAPI = /** @class */ (function (_super) {
    __extends(YAxisSeriesConfigAPI, _super);
    function YAxisSeriesConfigAPI(seriesName, seriesConfig, chartDef) {
        return _super.call(this, seriesName, seriesConfig, chartDef) || this;
    }
    /**
     * Set the label for the series.
     */
    YAxisSeriesConfigAPI.prototype.label = function (label) {
        this.seriesConfig.label = label;
        return this;
    };
    /**
     * Set the display format for values of this series.
     */
    YAxisSeriesConfigAPI.prototype.format = function (formatString) {
        this.seriesConfig.format = formatString;
        return this;
    };
    /**
     * Configure an explicit x axis for this series.
     */
    YAxisSeriesConfigAPI.prototype.setX = function (seriesName) {
        if (!this.seriesConfig.x) {
            this.seriesConfig.x = { series: seriesName };
        }
        else {
            this.seriesConfig.x.series = seriesName;
        }
        return new XAxisSeriesConfigAPI("x", this.seriesConfig.x, this.chartDef);
    };
    return YAxisSeriesConfigAPI;
}(AxisSeriesConfigAPI));
/**
 * Fluent API for configuring an axis of the chart.
 */
var AxisConfigAPI = /** @class */ (function (_super) {
    __extends(AxisConfigAPI, _super);
    function AxisConfigAPI(axisName, axisConfig, chartDef) {
        var _this = _super.call(this, chartDef) || this;
        _this.axisName = axisName;
        _this.axisConfig = axisConfig;
        return _this;
    }
    /**
     * Set the label for the axis.
     */
    AxisConfigAPI.prototype.label = function (label) {
        if (!this.axisConfig.label) {
            this.axisConfig.label = {};
        }
        this.axisConfig.label.text = label;
        return this;
    };
    return AxisConfigAPI;
}(AbstractPlotAPI));
/**
 * Fluent API for configuring an axis of the chart.
 */
var XAxisConfigAPI = /** @class */ (function (_super) {
    __extends(XAxisConfigAPI, _super);
    function XAxisConfigAPI(axisName, axisConfig, createSeriesConfig, chartDef) {
        var _this = _super.call(this, axisName, axisConfig, chartDef) || this;
        _this.createSeriesConfig = createSeriesConfig;
        return _this;
    }
    /**
     * Set the series for the x axis.
     */
    XAxisConfigAPI.prototype.setSeries = function (seriesName) {
        return new XAxisSeriesConfigAPI(seriesName, this.createSeriesConfig(seriesName), this.chartDef);
    };
    /**
     * Set the type of the axis.
     */
    XAxisConfigAPI.prototype.type = function (axisType) {
        this.axisConfig.axisType = axisType;
        return this;
    };
    /**
     * Set the position for the label.
     */
    XAxisConfigAPI.prototype.labelPosition = function (position) {
        if (!this.axisConfig.label) {
            this.axisConfig.label = {};
        }
        this.axisConfig.label.position = position;
        return this;
    };
    return XAxisConfigAPI;
}(AxisConfigAPI));
/**
 * Fluent API for configuring an axis of the chart.
 */
var YAxisConfigAPI = /** @class */ (function (_super) {
    __extends(YAxisConfigAPI, _super);
    function YAxisConfigAPI(axisName, axisConfig, createSeriesConfig, chartDef) {
        var _this = _super.call(this, axisName, axisConfig, chartDef) || this;
        _this.createSeriesConfig = createSeriesConfig;
        return _this;
    }
    /**
     * Add a series to a Y axis.
     */
    YAxisConfigAPI.prototype.addSeries = function (seriesName) {
        return new YAxisSeriesConfigAPI(seriesName, this.createSeriesConfig(seriesName), this.chartDef);
    };
    /**
     * Set the position for the label.
     */
    YAxisConfigAPI.prototype.labelPosition = function (position) {
        if (!this.axisConfig.label) {
            this.axisConfig.label = {};
        }
        else if (typeof (this.axisConfig.label) === "string") {
            this.axisConfig.label = {
                text: this.axisConfig.label,
            };
        }
        this.axisConfig.label.position = position;
        return this;
    };
    /**
     * Sets the minimum value to render on the axis.
     * @param value The minimum value to render.
     */
    YAxisConfigAPI.prototype.min = function (value) {
        // todo:
        return this;
    };
    /**
     * Sets the maximum value to render on the axis.
     * @param value The maximum value to render.
     */
    YAxisConfigAPI.prototype.max = function (value) {
        // todo:
        return this;
    };
    return YAxisConfigAPI;
}(AxisConfigAPI));
//# sourceMappingURL=plot-api.js.map