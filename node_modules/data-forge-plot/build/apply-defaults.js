"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chart_def_1 = require("@data-forge-plot/chart-def");
var expand_chart_def_1 = require("./expand-chart-def");
//
// Extract series from the chart definition's data.
//
function extractValues(data, seriesConfigs) {
    var values = seriesConfigs
        .filter(function (axis) { return data && data.columns && data.columns[axis.series] === "number"; })
        .map(function (axis) { return data.values && data.values.map(function (row) { return row[axis.series]; }) || []; });
    var flattened = [].concat.apply([], values); // Flatten array of arrays.
    return flattened;
}
function computeMin(values) {
    return Math.floor(Math.min.apply(Math, values.filter(function (v) { return v !== undefined && v !== null && !Number.isNaN(v); })) * 100) / 100;
}
function computeMax(values) {
    return Math.ceil(Math.max.apply(Math, values.filter(function (v) { return v !== undefined && v !== null && !Number.isNaN(v) && Number.isFinite(v); })) * 100) / 100;
}
//
// Apply defaults to a chart definition and patch misssing values.
//
function applyDefaults(inputChartDef, plotDefaults) {
    var chartDef = Object.assign({}, inputChartDef);
    if (!chartDef.plotConfig) {
        if (plotDefaults) {
            chartDef.plotConfig = Object.assign({}, expand_chart_def_1.expandPlotConfig(plotDefaults));
        }
        else {
            chartDef.plotConfig = {};
        }
    }
    else {
        if (plotDefaults) {
            chartDef.plotConfig = Object.assign({}, expand_chart_def_1.expandPlotConfig(plotDefaults), chartDef.plotConfig);
        }
        else {
            chartDef.plotConfig = Object.assign({}, chartDef.plotConfig);
        }
    }
    if (chartDef.plotConfig.chartType === undefined) {
        chartDef.plotConfig.chartType = chart_def_1.ChartType.Line;
    }
    if (chartDef.plotConfig.width === undefined) {
        chartDef.plotConfig.width = 800;
    }
    if (chartDef.plotConfig.height === undefined) {
        chartDef.plotConfig.height = 600;
    }
    if (!chartDef.axisMap) {
        chartDef.axisMap = { y: [], y2: [] };
    }
    else {
        chartDef.axisMap = Object.assign({}, chartDef.axisMap);
        if (!chartDef.axisMap.y) {
            chartDef.axisMap.y = [];
        }
        if (!chartDef.axisMap.y2) {
            chartDef.axisMap.y2 = [];
        }
    }
    if (chartDef.axisMap.y.length === 0 &&
        chartDef.axisMap.y2.length === 0) {
        chartDef.axisMap.y = expand_chart_def_1.expandYSeriesConfigArray(chartDef.data.columnOrder);
    }
    if (!chartDef.plotConfig.y) {
        chartDef.plotConfig.y = {};
    }
    var y1Values;
    if (chartDef.plotConfig.y.min === undefined) {
        y1Values = extractValues(chartDef.data, chartDef.axisMap.y);
        if (y1Values.length > 0) {
            chartDef.plotConfig.y.min = computeMin(y1Values);
        }
    }
    if (chartDef.plotConfig.y.max === undefined) {
        if (!y1Values) {
            y1Values = extractValues(chartDef.data, chartDef.axisMap.y);
        }
        if (y1Values.length > 0) {
            chartDef.plotConfig.y.max = computeMax(y1Values);
        }
    }
    if (!chartDef.plotConfig.y2) {
        chartDef.plotConfig.y2 = {};
    }
    var y2Values;
    if (chartDef.plotConfig.y2.min === undefined) {
        y2Values = extractValues(chartDef.data, chartDef.axisMap.y2);
        if (y2Values.length > 0) {
            chartDef.plotConfig.y2.min = computeMin(y2Values);
        }
    }
    if (chartDef.plotConfig.y2.max === undefined) {
        if (!y2Values) {
            y2Values = extractValues(chartDef.data, chartDef.axisMap.y2);
        }
        if (y2Values.length > 0) {
            chartDef.plotConfig.y2.max = computeMax(y2Values);
        }
    }
    return chartDef;
}
exports.applyDefaults = applyDefaults;
//# sourceMappingURL=apply-defaults.js.map